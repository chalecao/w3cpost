---
title: 浅克隆与深克隆

---
<div>
 实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.
  
 [我们](https://www.w3cdoc.com)就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.
  
 在要实现一个深克隆之前[我们](https://www.w3cdoc.com)需要了解一下javascript中的基础类型. <a href="https://www.f2e123.com/question/javascriptyounajizhongshujuleixing">javascript有哪几种数据类型</a>
  
  <blockquote>
    
      JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol
    
  </blockquote>
  <blockquote>
    
      JavaScript引用类型:Object
    
  </blockquote>
  <hr />
  <h4 class="heading" data-id="heading-2">
    1.浅克隆
  </h4>
浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-comment">// 浅克隆函数&lt;/span>
&lt;span class="hljs-function">&lt;span class="hljs-keyword">function&lt;/span> &lt;span class="hljs-title">shallowClone&lt;/span>(&lt;span class="hljs-params">o&lt;/span>) &lt;/span>{
  &lt;span class="hljs-keyword">const&lt;/span> obj = {};
  &lt;span class="hljs-keyword">for&lt;/span> ( &lt;span class="hljs-keyword">let&lt;/span> i &lt;span class="hljs-keyword">in&lt;/span> o) {
    obj[i] = o[i];
  }
  &lt;span class="hljs-keyword">return&lt;/span> obj;
}
&lt;span class="hljs-comment">// 被克隆对象&lt;/span>
&lt;span class="hljs-keyword">const&lt;/span> oldObj = {
  &lt;span class="hljs-attr">a&lt;/span>: &lt;span class="hljs-number">1&lt;/span>,
  &lt;span class="hljs-attr">b&lt;/span>: [ &lt;span class="hljs-string">'e'&lt;/span>, &lt;span class="hljs-string">'f'&lt;/span>, &lt;span class="hljs-string">'g'&lt;/span> ],
  &lt;span class="hljs-attr">c&lt;/span>: { &lt;span class="hljs-attr">h&lt;/span>: { &lt;span class="hljs-attr">i&lt;/span>: &lt;span class="hljs-number">2&lt;/span> } }
};

&lt;span class="hljs-keyword">const&lt;/span> newObj = shallowClone(oldObj);
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c.h, oldObj.c.h); &lt;span class="hljs-comment">// { i: 2 } { i: 2 }&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(oldObj.c.h === newObj.c.h); &lt;span class="hljs-comment">// true&lt;/span>

&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 [我们](https://www.w3cdoc.com)可以看到,很明显虽然<code>oldObj.c.h</code>被克隆了,但是它还与<code>oldObj.c.h</code>相等,这表明他们依然指向同一段堆内存,这就造成了如果对<code>newObj.c.h</code>进行修改,也会影响<code>oldObj.c.h</code>,这就不是一版好的克隆.
  
  <pre><code class="hljs javascript copyable" lang="javascript">newObj.c.h.i = &lt;span class="hljs-string">'change'&lt;/span>;
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c.h, oldObj.c.h); &lt;span class="hljs-comment">// { i: 'change' } { i: 'change' }&lt;/span>
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 [我们](https://www.w3cdoc.com)改变了<code>newObj.c.h.i</code>的值,<code>oldObj.c.h.i</code>也被改变了,这就是浅克隆的问题所在.
  
 当然有一个新的api<code>Object.assign()</code>也可以实现浅复制,但是效果跟上面没有差别,所以[我们](https://www.w3cdoc.com)不再细说了.
  
  <h4 class="heading" data-id="heading-3">
    2.深克隆
  </h4>
  <h5 class="heading" data-id="heading-4">
    2.1 JSON.parse方法
  </h5>
 前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> newObj = &lt;span class="hljs-built_in">JSON&lt;/span>.parse(&lt;span class="hljs-built_in">JSON&lt;/span>.stringify(oldObj));
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 [我们](https://www.w3cdoc.com)依然用上一节的例子进行测试
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> oldObj = {
  &lt;span class="hljs-attr">a&lt;/span>: &lt;span class="hljs-number">1&lt;/span>,
  &lt;span class="hljs-attr">b&lt;/span>: [ &lt;span class="hljs-string">'e'&lt;/span>, &lt;span class="hljs-string">'f'&lt;/span>, &lt;span class="hljs-string">'g'&lt;/span> ],
  &lt;span class="hljs-attr">c&lt;/span>: { &lt;span class="hljs-attr">h&lt;/span>: { &lt;span class="hljs-attr">i&lt;/span>: &lt;span class="hljs-number">2&lt;/span> } }
};

&lt;span class="hljs-keyword">const&lt;/span> newObj = &lt;span class="hljs-built_in">JSON&lt;/span>.parse(&lt;span class="hljs-built_in">JSON&lt;/span>.stringify(oldObj));
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c.h, oldObj.c.h); &lt;span class="hljs-comment">// { i: 2 } { i: 2 }&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(oldObj.c.h === newObj.c.h); &lt;span class="hljs-comment">// false&lt;/span>
newObj.c.h.i = &lt;span class="hljs-string">'change'&lt;/span>;
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c.h, oldObj.c.h); &lt;span class="hljs-comment">// { i: 'change' } { i: 2 }&lt;/span>

&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.
  
 确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.
  
  <blockquote>
    
      1.他无法实现对函数 、RegExp等特殊对象的克隆
    
  </blockquote>
  <blockquote>
    
      2.会抛弃对象的constructor,所有的构造函数会指向Object
    
  </blockquote>
  <blockquote>
    
      3.对象有循环引用,会报错
    
  </blockquote>
 主要的坑就是以上几点,[我们](https://www.w3cdoc.com)一一测试下.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-comment">// 构造函数&lt;/span>
&lt;span class="hljs-function">&lt;span class="hljs-keyword">function&lt;/span> &lt;span class="hljs-title">person&lt;/span>(&lt;span class="hljs-params">pname&lt;/span>) &lt;/span>{
  &lt;span class="hljs-keyword">this&lt;/span>.name = pname;
}

&lt;span class="hljs-keyword">const&lt;/span> Messi = &lt;span class="hljs-keyword">new&lt;/span> person(&lt;span class="hljs-string">'Messi'&lt;/span>);

&lt;span class="hljs-comment">// 函数&lt;/span>
&lt;span class="hljs-function">&lt;span class="hljs-keyword">function&lt;/span> &lt;span class="hljs-title">say&lt;/span>() &lt;/span>{
  &lt;span class="hljs-built_in">console&lt;/span>.log(&lt;span class="hljs-string">'hi'&lt;/span>);
};

&lt;span class="hljs-keyword">const&lt;/span> oldObj = {
  &lt;span class="hljs-attr">a&lt;/span>: say,
  &lt;span class="hljs-attr">b&lt;/span>: &lt;span class="hljs-keyword">new&lt;/span> &lt;span class="hljs-built_in">Array&lt;/span>(&lt;span class="hljs-number">1&lt;/span>),
  &lt;span class="hljs-attr">c&lt;/span>: &lt;span class="hljs-keyword">new&lt;/span> &lt;span class="hljs-built_in">RegExp&lt;/span>(&lt;span class="hljs-string">'ab+c'&lt;/span>, &lt;span class="hljs-string">'i'&lt;/span>),
  &lt;span class="hljs-attr">d&lt;/span>: Messi
};

&lt;span class="hljs-keyword">const&lt;/span> newObj = &lt;span class="hljs-built_in">JSON&lt;/span>.parse(&lt;span class="hljs-built_in">JSON&lt;/span>.stringify(oldObj));

&lt;span class="hljs-comment">// 无法复制函数&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.a, oldObj.a); &lt;span class="hljs-comment">// undefined [Function: say]&lt;/span>
&lt;span class="hljs-comment">// 稀疏数组复制错误&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.b[&lt;span class="hljs-number">0&lt;/span>], oldObj.b[&lt;span class="hljs-number">0&lt;/span>]); &lt;span class="hljs-comment">// null undefined&lt;/span>
&lt;span class="hljs-comment">// 无法复制正则对象&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c, oldObj.c); &lt;span class="hljs-comment">// {} /ab+c/i&lt;/span>
&lt;span class="hljs-comment">// 构造函数指向错误&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.d.constructor, oldObj.d.constructor); &lt;span class="hljs-comment">// [Function: Object] [Function: person]&lt;/span>

&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 [我们](https://www.w3cdoc.com)可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> oldObj = {};

oldObj.a = oldObj;

&lt;span class="hljs-keyword">const&lt;/span> newObj = &lt;span class="hljs-built_in">JSON&lt;/span>.parse(&lt;span class="hljs-built_in">JSON&lt;/span>.stringify(oldObj));
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.a, oldObj.a); &lt;span class="hljs-comment">// TypeError: Converting circular structure to JSON&lt;/span>
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 对象的循环引用会抛出错误.
  
  <h5 class="heading" data-id="heading-5">
    2.2 构造一个深克隆函数
  </h5>
 [我们](https://www.w3cdoc.com)知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.
  <figure><figcaption></figcaption></figure>
 <em>(这个方法也会出现上一节提到的问题)</em>由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，[我们](https://www.w3cdoc.com)需要实现一个对象类型判断函数。
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> isType = &lt;span class="hljs-function">(&lt;span class="hljs-params">obj, type&lt;/span>) =>&lt;/span> {
  &lt;span class="hljs-keyword">if&lt;/span> (&lt;span class="hljs-keyword">typeof&lt;/span> obj !== &lt;span class="hljs-string">'object'&lt;/span>) &lt;span class="hljs-keyword">return&lt;/span> &lt;span class="hljs-literal">false&lt;/span>;
  &lt;span class="hljs-keyword">const&lt;/span> typeString = &lt;span class="hljs-built_in">Object&lt;/span>.prototype.toString.call(obj);
  &lt;span class="hljs-keyword">let&lt;/span> flag;
  &lt;span class="hljs-keyword">switch&lt;/span> (type) {
    &lt;span class="hljs-keyword">case&lt;/span> &lt;span class="hljs-string">'Array'&lt;/span>:
      flag = typeString === &lt;span class="hljs-string">'[object Array]'&lt;/span>;
      &lt;span class="hljs-keyword">break&lt;/span>;
    &lt;span class="hljs-keyword">case&lt;/span> &lt;span class="hljs-string">'Date'&lt;/span>:
      flag = typeString === &lt;span class="hljs-string">'[object Date]'&lt;/span>;
      &lt;span class="hljs-keyword">break&lt;/span>;
    &lt;span class="hljs-keyword">case&lt;/span> &lt;span class="hljs-string">'RegExp'&lt;/span>:
      flag = typeString === &lt;span class="hljs-string">'[object RegExp]'&lt;/span>;
      &lt;span class="hljs-keyword">break&lt;/span>;
    &lt;span class="hljs-keyword">default&lt;/span>:
      flag = &lt;span class="hljs-literal">false&lt;/span>;
  }
  &lt;span class="hljs-keyword">return&lt;/span> flag;
};
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 这样[我们](https://www.w3cdoc.com)就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> arr = &lt;span class="hljs-built_in">Array&lt;/span>.of(&lt;span class="hljs-number">3&lt;/span>, &lt;span class="hljs-number">4&lt;/span>, &lt;span class="hljs-number">5&lt;/span>, &lt;span class="hljs-number">2&lt;/span>);

&lt;span class="hljs-built_in">console&lt;/span>.log(isType(arr, &lt;span class="hljs-string">'Array'&lt;/span>)); &lt;span class="hljs-comment">// true&lt;/span>
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 对于正则对象,[我们](https://www.w3cdoc.com)在处理之前要先补充一点新知识.
  
 [我们](https://www.w3cdoc.com)需要通过<a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fregex%23flags-%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="nofollow noopener noreferrer">正则的扩展</a>了解到<code>flags</code>属性等等,因此[我们](https://www.w3cdoc.com)需要实现一个提取flags的函数.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-keyword">const&lt;/span> getRegExp = &lt;span class="hljs-function">&lt;span class="hljs-params">re&lt;/span> =>&lt;/span> {
  &lt;span class="hljs-keyword">var&lt;/span> flags = &lt;span class="hljs-string">''&lt;/span>;
  &lt;span class="hljs-keyword">if&lt;/span> (re.global) flags += &lt;span class="hljs-string">'g'&lt;/span>;
  &lt;span class="hljs-keyword">if&lt;/span> (re.ignoreCase) flags += &lt;span class="hljs-string">'i'&lt;/span>;
  &lt;span class="hljs-keyword">if&lt;/span> (re.multiline) flags += &lt;span class="hljs-string">'m'&lt;/span>;
  &lt;span class="hljs-keyword">return&lt;/span> flags;
};
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 做好了这些准备工作,[我们](https://www.w3cdoc.com)就可以进行深克隆的实现了.
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-comment">/**
* deep clone
* @param  {[type]} parent object 需要进行克隆的对象
* @return {[type]}        深克隆后的对象
*/&lt;/span>
&lt;span class="hljs-keyword">const&lt;/span> clone = &lt;span class="hljs-function">&lt;span class="hljs-params">parent&lt;/span> =>&lt;/span> {
  &lt;span class="hljs-comment">// 维护两个储存循环引用的数组&lt;/span>
  &lt;span class="hljs-keyword">const&lt;/span> parents = [];
  &lt;span class="hljs-keyword">const&lt;/span> children = [];

  &lt;span class="hljs-keyword">const&lt;/span> _clone = &lt;span class="hljs-function">&lt;span class="hljs-params">parent&lt;/span> =>&lt;/span> {
    &lt;span class="hljs-keyword">if&lt;/span> (parent === &lt;span class="hljs-literal">null&lt;/span>) &lt;span class="hljs-keyword">return&lt;/span> &lt;span class="hljs-literal">null&lt;/span>;
    &lt;span class="hljs-keyword">if&lt;/span> (&lt;span class="hljs-keyword">typeof&lt;/span> parent !== &lt;span class="hljs-string">'object'&lt;/span>) &lt;span class="hljs-keyword">return&lt;/span> parent;

    &lt;span class="hljs-keyword">let&lt;/span> child, proto;

    &lt;span class="hljs-keyword">if&lt;/span> (isType(parent, &lt;span class="hljs-string">'Array'&lt;/span>)) {
      &lt;span class="hljs-comment">// 对数组做特殊处理&lt;/span>
      child = [];
    } &lt;span class="hljs-keyword">else&lt;/span> &lt;span class="hljs-keyword">if&lt;/span> (isType(parent, &lt;span class="hljs-string">'RegExp'&lt;/span>)) {
      &lt;span class="hljs-comment">// 对正则对象做特殊处理&lt;/span>
      child = &lt;span class="hljs-keyword">new&lt;/span> &lt;span class="hljs-built_in">RegExp&lt;/span>(parent.source, getRegExp(parent));
      &lt;span class="hljs-keyword">if&lt;/span> (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } &lt;span class="hljs-keyword">else&lt;/span> &lt;span class="hljs-keyword">if&lt;/span> (isType(parent, &lt;span class="hljs-string">'Date'&lt;/span>)) {
      &lt;span class="hljs-comment">// 对Date对象做特殊处理&lt;/span>
      child = &lt;span class="hljs-keyword">new&lt;/span> &lt;span class="hljs-built_in">Date&lt;/span>(parent.getTime());
    } &lt;span class="hljs-keyword">else&lt;/span> {
      &lt;span class="hljs-comment">// 处理对象原型&lt;/span>
      proto = &lt;span class="hljs-built_in">Object&lt;/span>.getPrototypeOf(parent);
      &lt;span class="hljs-comment">// 利用Object.create切断原型链&lt;/span>
      child = &lt;span class="hljs-built_in">Object&lt;/span>.create(proto);
    }

    &lt;span class="hljs-comment">// 处理循环引用&lt;/span>
    &lt;span class="hljs-keyword">const&lt;/span> index = parents.indexOf(parent);

    &lt;span class="hljs-keyword">if&lt;/span> (index != &lt;span class="hljs-number">-1&lt;/span>) {
      &lt;span class="hljs-comment">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象&lt;/span>
      &lt;span class="hljs-keyword">return&lt;/span> children[index];
    }
    parents.push(parent);
    children.push(child);

    &lt;span class="hljs-keyword">for&lt;/span> (&lt;span class="hljs-keyword">let&lt;/span> i &lt;span class="hljs-keyword">in&lt;/span> parent) {
      &lt;span class="hljs-comment">// 递归&lt;/span>
      child[i] = _clone(parent[i]);
    }

    &lt;span class="hljs-keyword">return&lt;/span> child;
  };
  &lt;span class="hljs-keyword">return&lt;/span> _clone(parent);
};
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 [我们](https://www.w3cdoc.com)做一下测试
  
  <pre><code class="hljs javascript copyable" lang="javascript">&lt;span class="hljs-function">&lt;span class="hljs-keyword">function&lt;/span> &lt;span class="hljs-title">person&lt;/span>(&lt;span class="hljs-params">pname&lt;/span>) &lt;/span>{
  &lt;span class="hljs-keyword">this&lt;/span>.name = pname;
}

&lt;span class="hljs-keyword">const&lt;/span> Messi = &lt;span class="hljs-keyword">new&lt;/span> person(&lt;span class="hljs-string">'Messi'&lt;/span>);

&lt;span class="hljs-function">&lt;span class="hljs-keyword">function&lt;/span> &lt;span class="hljs-title">say&lt;/span>() &lt;/span>{
  &lt;span class="hljs-built_in">console&lt;/span>.log(&lt;span class="hljs-string">'hi'&lt;/span>);
}

&lt;span class="hljs-keyword">const&lt;/span> oldObj = {
  &lt;span class="hljs-attr">a&lt;/span>: say,
  &lt;span class="hljs-attr">c&lt;/span>: &lt;span class="hljs-keyword">new&lt;/span> &lt;span class="hljs-built_in">RegExp&lt;/span>(&lt;span class="hljs-string">'ab+c'&lt;/span>, &lt;span class="hljs-string">'i'&lt;/span>),
  &lt;span class="hljs-attr">d&lt;/span>: Messi,
};

oldObj.b = oldObj;

&lt;span class="hljs-keyword">const&lt;/span> newObj = clone(oldObj);
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.a, oldObj.a); &lt;span class="hljs-comment">// [Function: say] [Function: say]&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.b, oldObj.b); &lt;span class="hljs-comment">// { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.c, oldObj.c); &lt;span class="hljs-comment">// /ab+c/i /ab+c/i&lt;/span>
&lt;span class="hljs-built_in">console&lt;/span>.log(newObj.d.constructor, oldObj.d.constructor); &lt;span class="hljs-comment">// [Function: person] [Function: person]&lt;/span>
&lt;span class="copy-code-btn">复制代码&lt;/span></code></pre>
 当然,[我们](https://www.w3cdoc.com)这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要[我们](https://www.w3cdoc.com)做特殊处理，另外对于确保没有循环引用的对象，[我们](https://www.w3cdoc.com)可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数[我们](https://www.w3cdoc.com)已经实现了。
  
  <h3>
    基于拆箱装箱深克隆
  </h3>
 参考：<a href="https://www.f2e123.com/javascriptnodejs/1691.html">ES6黑科技之 &#8230; 拆箱与装箱</a>
  
  <h3 class="heading" data-id="heading-6">
    总结
  </h3>
 实现一个完整的深克隆是由许多坑要踩的,npm上一些库的实现也不够完整,在生产环境中最好用<code>lodash</code>的深克隆实现.
  
 在面试过程中,[我们](https://www.w3cdoc.com)上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.
</div>

### 扩展阅读


  <a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">面试官:请你实现一个深克隆</a>

[ES6黑科技之 &#8230; 拆箱与装箱][1]

 [1]: https://www.f2e123.com/javascriptnodejs/1691.html
