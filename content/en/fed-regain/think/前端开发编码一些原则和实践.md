---
title: 前端开发编码一些原则和实践


date: 2020-07-25T08:16:40+00:00
url: /javascriptnodejs/5832.html
views:
  - 870
like:
  - 2


---
<h2 id="zmCaP" data-lake-id="3e9b8402949a9e9caa3eeca696313fec_h2_0">
  开发原则
</h2>

<p data-lake-id="a6c74fcfc33a0c619f6a88e87468db4b_p_8">
  在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。<br /> 以下是面向对象设计的原则，react hooks更多的是函数式编程，参考下面函数式编程实践
</p>

<p data-lake-id="e1ae29934df7312c907c55ba6c6bd381_p_9">
  1. 单一职责（SRP）
</p>

<p data-lake-id="3fc91de90796adbc6db5deff68de9892_p_10">
  2. 开放—封闭原则（OCP）
</p>

<p data-lake-id="7fc7c48514727e59b44f2aa1ad9136a5_p_11">
  3. Liskov替换原则（LSP）
</p>

<p data-lake-id="b2d13d99fe7c3c18aa961a3cee236f3b_p_12">
  4. 依赖倒置原则（DIP）
</p>

<p data-lake-id="e1d6e78c5c842fd5db3ccb8238755c1d_p_13">
  5. 接口隔离原则（ISP）
</p>

<p data-lake-id="e1d6e78c5c842fd5db3ccb8238755c1d_p_13">
  6. 合成复用原则
</p>

<p data-lake-id="e1d6e78c5c842fd5db3ccb8238755c1d_p_13">
  7. 迪米特最少知识原则
</p>

<h1 id="6yXhB" data-lake-id="94f669e4f907c7e307a7b8f5b72591fd_h1_2">
  函数式编程最佳实践
</h1>

<p data-lake-id="170ec9dc3a3d47c43fc1da398cb5b437_p_15">
  业务开发推荐使用React Hooks编写组件，补充函数式编程最佳实践
</p>

<h2 id="Lcq0z" data-lake-id="68f501de2bf9b304d9d75c44c3e6d574_h2_1">
  原则
</h2>

<li data-lake-id="2d0517b3ff033bf70eb212de587e7e92_li_4">
  数据出入原则
</li>

<p data-lake-id="757f11a1f02e4de61a19185e8e70c4d0_p_17">
  一个函数，只要拥有入参，必然要有返回
</p>

<li data-lake-id="c4cf1d01f96ba3dd854ff88b855e9c94_li_5">
  无状态原则
</li>

<p data-lake-id="f9a07755283d3a7eda6f87440ce1f102_p_19">
  一个函数，对外依赖，只能通过参数的形式依赖，不能直接依赖全局变量，同时，参数一定是immutable数据，函数体内不能对参数做引用操作
</p>

<li data-lake-id="19f733a658d812c2b18572b32c974ded_li_6">
  不可变原则
</li>

<p data-lake-id="98498bee5f8a7c6d23686af098f68671_p_21">
  一个函数，不管是参数，还是其返回的数据类型，都不应该是可变数据，因为在js中是不存在原生的immutable的数据结构的，所以，我们只要保证模块函数返回的数据每次都是一个新引用，而不是持续操作同一个数据引用。比如：
</p>

<div id="6781d28a" contenteditable="false" data-card-type="block" data-lake-card="codeblock" data-card-value="data:%7B%22id%22%3A%226781d28a%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20func%20%3D%20(obj)%3D%3E%7B%5Cn%20%20%20return%20%7B...obj%7D%5Cn%7D%22%7D" data-language="javascript">
  <div class="lake-codeblock-content">
    <div class="">
      <pre class="cm-s-default"><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">func</span> <span class="cm-operator">=</span> (<span class="cm-def">obj</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">return</span> {<span class="cm-meta">...</span><span class="cm-variable-2">obj</span>}
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">}</span></span></pre>
    </div>
  </div>
</div>

<li data-lake-id="a1d68f6cd04df218edc3834660740d99_li_7">
  最小粒度原则
</li>

<p data-lake-id="8e33e5779392f743716463fd2ee28d3e_p_23">
  函数与功能的对应关系是完全一对一关系，禁止一个函数存在多个功能(以数学思路来说，就是写一系列的小型公式集合)
</p>

<li data-lake-id="636b444b9f984362bbf8d70b3851eaa2_li_8">
  函数组合原则
</li>

<p data-lake-id="03b8a78411985552bf48c235c90c2eb1_p_25">
  在最小粒度原则的前提下，需要借助函数组合原则构建出一个最终大函数(或者说是一个大公式)
</p>

<h2 id="kkc4e" data-lake-id="aed10e42caab95c8cea1ceda90f0f592_h2_2">
  最佳实践
</h2>

<li data-lake-id="3d5b73110e3a4a19b6ce4e0bc3d81ac4_li_9">
  避免使用javascript中的命令式语法(if/for/switch)
</li>

<p data-lake-id="c0428c65bbf7ae6ced1ceba9964c914d_p_28">
  尽量使用封装好的函数库或者ES6/7原生可用函数API，比如map/reduce/some/every等等，但是，如果是遍历操作，推荐用reduce，因为借助reduce，可以在一次循环里做很多事情，性能可以提升很大，比如：
</p>

<div id="e03169ec" contenteditable="false" data-card-type="block" data-lake-card="codeblock" data-card-value="data:%7B%22id%22%3A%22e03169ec%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20result%20%3D%20arr.map((item)%3D%3E%7B%5Cn%20%20return%20item.age%5Cn%7D).filter(item%3D%3Eitem%20%3E%2018)%5Cn%5Cn%2F%2F%20good%5Cnconst%20result%20%3D%20arr.reduce((buf%2Citem)%3D%3E%7B%5Cn%20%20%20return%20item.age%20%3E%2018%20%3F%20buf.concat(item.age)%20%3A%20buf%5Cn%7D%2C%5B%5D)%22%7D" data-language="javascript">
  <div class="lake-codeblock-content">
    <div class="">
      <pre class="cm-s-default"><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">// bad</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">arr</span>.<span class="cm-property">map</span>((<span class="cm-def">item</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">  <span class="cm-keyword">return</span> <span class="cm-variable-2">item</span>.<span class="cm-property">age</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">}).<span class="cm-property">filter</span>(<span class="cm-def">item</span><span class="cm-operator">=&gt;</span><span class="cm-variable-2">item</span> <span class="cm-operator">&gt;</span> <span class="cm-number">18</span>)
</span></span>
<span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">// good</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">arr</span>.<span class="cm-property">reduce</span>((<span class="cm-def">buf</span>,<span class="cm-def">item</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">return</span> <span class="cm-variable-2">item</span>.<span class="cm-property">age</span> <span class="cm-operator">&gt;</span> <span class="cm-number">18</span> <span class="cm-operator">?</span> <span class="cm-variable-2">buf</span>.<span class="cm-property">concat</span>(<span class="cm-variable-2">item</span>.<span class="cm-property">age</span>) : <span class="cm-variable-2">buf</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">},[])</span></span></pre>
    </div>
  </div>
</div>

<li data-lake-id="c192fd394f55714ae9f7019d9f4438c2_li_10">
  借助Promise链降低异步操作副作用
</li>

<p data-lake-id="e77af12e0b62a4d0a9b9a5714167debb_p_31">
  如果一个数据处理流有可能存在异步操作(与异步请求相关，或者与异步交互相关)，那这个函数的返回值推荐返回Promise对象
</p>

<li data-lake-id="b87fddd01f7b93e755de091b15206a03_li_11">
  参数函数化
</li>

<p data-lake-id="b275f07d8627c66e34fa8e8479c012f9_p_33">
  基于最小粒度原则与函数组合原则，如果要增强函数的能力，我们是不可能在一个函数内部直接扩展它的功能，那样会造成函数越来越臃肿，所以，借助参数函数化，我们可以轻松的把功能扩展解耦出去
</p>

<div id="7e320a07" contenteditable="false" data-card-type="block" data-lake-card="codeblock" data-card-value="data:%7B%22id%22%3A%227e320a07%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20handler%20%3D%20(data%2Coptions)%3D%3E%7B%5Cn%20%20%20....default%20handler%5Cn%20%20%20if(options.ext1)%7B%5Cn%20%20%20%20%20%20....%20extension%201%20handler%5Cn%20%20%20%7D%5Cn%20%20%20%5Cn%20%20%20if(options.ext2)%7B%5Cn%20%20%20%20%20%20....%20extension%202%20handler%5Cn%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20handler%20%3D%20(data%2Cfunc)%3D%3E%7B%5Cn%20%20%20....default%20handler%5Cn%20%20%20if(isFn(func))%7B%5Cn%20%20%20%20%20%20....%20func(data)%5Cn%20%20%20%7D%5Cn%7D%22%7D" data-language="javascript">
  <div class="lake-codeblock-content">
    <div class="">
      <pre class="cm-s-default"><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">// bad</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">handler</span> <span class="cm-operator">=</span> (<span class="cm-def">data</span>,<span class="cm-def">options</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-meta">...</span>.<span class="cm-variable">default</span> <span class="cm-variable">handler</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">if</span>(<span class="cm-variable-2">options</span>.<span class="cm-property">ext1</span>){
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">      <span class="cm-meta">...</span>. <span class="cm-variable">extension</span> <span class="cm-number">1</span> <span class="cm-variable">handler</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   }
</span></span>   
<span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">if</span>(<span class="cm-variable-2">options</span>.<span class="cm-property">ext2</span>){
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">      <span class="cm-meta">...</span>. <span class="cm-variable">extension</span> <span class="cm-number">2</span> <span class="cm-variable">handler</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   }
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">}
</span></span>
<span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">// good</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">handler</span> <span class="cm-operator">=</span> (<span class="cm-def">data</span>,<span class="cm-def">func</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-meta">...</span>.<span class="cm-variable">default</span> <span class="cm-variable">handler</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">if</span>(<span class="cm-variable">isFn</span>(<span class="cm-variable-2">func</span>)){
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">      <span class="cm-meta">...</span>. <span class="cm-variable-2">func</span>(<span class="cm-variable-2">data</span>)
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   }
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">}</span></span></pre>
    </div>
  </div>
</div>

<li data-lake-id="47137a0885d38da09670b407e6faf4e8_li_12">
  返回函数化(科里化)
</li>

<p data-lake-id="0376d67556d034e4b2fa4d4871689b7c_p_36">
  之前常说的科里化，其实就是函数返回值也是一个函数，这样所带来的好处是一个函数生产出一系列更加富有语义性，调用更加方便的函数集合，同时，它还可以用于减少参数数量。比如类型判断：
</p>

<div id="a4a06213" contenteditable="false" data-card-type="block" data-lake-card="codeblock" data-card-value="data:%7B%22id%22%3A%22a4a06213%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%E8%BF%87%E5%8E%BB%5Cnconst%20isType%20%3D%20(value%2Ctype)%3D%3E%7B%5Cn%20%20%20return%20value%20!%3D%20null%20%26%26%20Object.prototype.toString.call(value)%20%3D%3D%3D%20%60%5Bobject%20%24%7Btype%7D%5D%60%5Cn%7D%5Cn%2F%2F%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%BE%88%E9%BA%BB%E7%83%A6%EF%BC%8C%E6%AF%8F%E6%AC%A1%E9%83%BD%E9%9C%80%E8%A6%81%E4%BC%A0%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%5Cnif(isType(%7B%7D%2C%5C%22Array%5C%22))%7B....%7D%5Cn%5Cn%2F%2F%E7%8E%B0%E5%9C%A8%5Cnconst%20isType%20%3D%20type%20%3D%3E%20obj%20%3D%3E%5Cn%20%20%20%20obj%20!%3D%20null%20%26%26%20Object.prototype.toString.call(obj)%20%3D%3D%3D%20%60%5Bobject%20%24%7Btype%7D%5D%60%5Cnconst%20isFn%20%3D%20isType(%5C%22Function%5C%22)%5Cnconst%20isArr%20%3D%20isType('Array')%5Cn%5Cnif(isFn(%7B%7D))%7B...%7D%22%7D" data-language="javascript">
  <div class="lake-codeblock-content">
    <div class="">
      <pre class="cm-s-default"><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">//过去</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">isType</span> <span class="cm-operator">=</span> (<span class="cm-def">value</span>,<span class="cm-def">type</span>)<span class="cm-operator">=&gt;</span>{
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">   <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">&</span><span class="cm-operator">&</span> <span class="cm-variable">Object</span>.<span class="cm-property">prototype</span>.<span class="cm-property">toString</span>.<span class="cm-property">call</span>(<span class="cm-variable-2">value</span>) <span class="cm-operator">===</span> <span class="cm-string-2">`[object ${</span><span class="cm-variable-2">type</span><span class="cm-string-2">}</span><span class="cm-string-2">]`</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">}
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">//使用的时候很麻烦，每次都需要传两个参数</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">if</span>(<span class="cm-variable">isType</span>({},<span class="cm-string">"Array"</span>)){<span class="cm-meta">...</span>.}
</span></span>
<span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-comment">//现在</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">isType</span> <span class="cm-operator">=</span> <span class="cm-def">type</span> <span class="cm-operator">=&gt;</span> <span class="cm-def">obj</span> <span class="cm-operator">=&gt;</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content">    <span class="cm-variable-2">obj</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">&</span><span class="cm-operator">&</span> <span class="cm-variable">Object</span>.<span class="cm-property">prototype</span>.<span class="cm-property">toString</span>.<span class="cm-property">call</span>(<span class="cm-variable-2">obj</span>) <span class="cm-operator">===</span> <span class="cm-string-2">`[object ${</span><span class="cm-variable-2">type</span><span class="cm-string-2">}</span><span class="cm-string-2">]`</span>
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">isFn</span> <span class="cm-operator">=</span> <span class="cm-variable">isType</span>(<span class="cm-string">"Function"</span>)
</span></span><span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">const</span> <span class="cm-def">isArr</span> <span class="cm-operator">=</span> <span class="cm-variable">isType</span>(<span class="cm-string">'Array'</span>)
</span></span>
<span class="lake-preview-line"><span class="lake-preview-codeblock-content"><span class="cm-keyword">if</span>(<span class="cm-variable">isFn</span>({})){<span class="cm-meta">...</span>}</span></span></pre>
    </div>
  </div>
</div>