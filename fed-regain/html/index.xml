<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>html on</title><link>/fed-regain/html/</link><description>Recent content in html on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:15 +0000</lastBuildDate><atom:link href="/fed-regain/html/index.xml" rel="self" type="application/rss+xml"/><item><title>HTML发展历史</title><link>/fed-regain/html/html%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/html%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</guid><description>HTML是Web统一语言，这些容纳在尖括号里的简单标签，构成了如今的Web，1991年，Tim Berners-Lee编写了一份叫做“HTML标签”的文档，里面包含了大约20个用来标记网页的HTML标签。他直接借用SGML的标记格式，也就是后来我们看到的HTML标记的格式。
从IETF到W3C：HTML 4之路 # HTML 1并不曾存在，HTML的第一个官方版本就是由IETF（互联网工程任务组）推出的HTML 2.0。问世之前，这个版本中的很多细则已经被实现，比如，1994年的Mosaic浏览器已经实现了在文档中嵌入图片的方法，后来HTML 2.0便吸纳了img这个标签。
后来，W3C取代IETF的角色，成为HTML的标准组织，1990年代的后的几年，HTML的版本被频繁修改，直到1999年的HTML 4.01， 至此，HTML到达了它的第一个拐点。
XHTML 1：XML风格的HTML # HTML在HTML 4.01之后的第一个修订版本就是XHTML 1.0，其中X代表“eXtensible”，扩展，当然也有人将之解读为 “eXtreme”，极端。XHTML 1.0是基于HTML 4.01的，并没有引入任何新标签或属性，唯一的区别是语法，HTML对语法比较随便，而 XHTML则要求XML般的严格语法。
使用严格的语法规范并非坏事，要求开发者使用单一的代码风格，比如，HTML4.01允许你使用大写或小写字母标识标记元素和属性，XHTML则只 允许小写字母。XHTML1.0的推出刚好碰上了CSS的崛起，Web开发设计者们开始意识到Web标准问题，基于XHTML的严格语法规范被视为编写 HTML代码的最佳实践。
W3C推出XHTML 1.1 # 如果说XHTML 1.0是XML风格的HTML，XHTML 1.1则是货真价实的XML。这意味着XHTML 1.1无法使用 text/htmlmime-type直接输出，然而，如果Web开发者使用XMLmime-type，则当时的主流浏览器，IE则压根不支持。看上去，W3C似乎正在与当时的Web脱节。
出力不讨好的XHTML 2 # 对W3C而言，到了HTML 4已经是功德圆满，他们的下一步工作是XHTML 2，希望将Web带向XML的光明未来。虽然XHTML 2听上去和XHTML 1类似，它们却有很多差别，XHTML 2不向前兼容，甚至不兼容之前的HTML。它是一种全新的语言，赤条条来去无牵挂。这实在是一场灾难。
WHATWG：与W3C决裂 # W3C闭门造车的作风引起了一些人的不满，来自Opera,Apple,以及Mozilla的代表开始表达反对声音。2004年，Opera的 Ian Hickson提议在HTML基础上进行扩展以适应新的Web应用，该提议遭到W3C的拒绝。于是，他们自发组织成立了超文本应用技术工作组，就是WHATWG。
从WebApps1.0到HTML 5 # 从一开始，WHATWG就和W3C走不同的路线，W3C对问题的讨论是集体投票，而WHATWG则由主笔IanHickson定度。表面上看，W3C更民主，然而事实上，各种内部纷争会使一些决议限于泥潭，在WHATWG，事情的进展会更容易，不过，主笔的权力并非无限大，他们的委员会可以 对那些过于偏执的主笔进行弹劾。
一开始，WHATWG的主要工作包括两部分，Web Forms 2.0和Web Apps 1.0，它们都是HTML的扩展，后来，他们合并到一起成为现在的HTML 5规范。在WHATWG致力于HTML 5的同时，W3C继续他们的XHTML 2.0，然而，他们慢慢地陷入困境。
2006年10月，Web之父Tim Berners-Lee发表了一篇博客文章，表示，从HTML走向XML的路是行不通的，几个月后，W3C组建了一个新的HTML工作组，他们非常明智地 选择了WHATWG的成果作为基础。这一转变带来一些困惑，W3C同时进行这两套规范，XHTML2和HTML 5（注意，W3C的HTTML5在5之前有个空格，而WHATWG的HTML 5则没有空格），而WHATWG也在进行着同样的工作。
XHTML已死：XHTML语法永存 # 这一混乱局面到了2009年开始变得清晰，W3C宣布终止XHTML2的工作，这是一份关于XHTML2的迟到的讣告。这一消息被那些XML的反对 者视为珍宝，他们借此嘲笑那些使用XHTML1规范的人，然而他们似乎忘记了，XHTML1和XHTML2是截然不同的东西。于此同时，XHTML1规范的制定者担心，XHTML1中的严格语法规范会被HTML 5弃用，这种担心后来证明是多余的，HTML 5既支持松散语法，也支持XHTML1般的严格语 法。</description></item><item><title>HTML元素嵌套约束</title><link>/fed-regain/html/html%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97%E7%BA%A6%E6%9D%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/html%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97%E7%BA%A6%E6%9D%9F/</guid><description>块级元素特点：
①总是在新行上开始，占据一整行（很霸道）； ②高度，行高以及外边距和内边距都可控制； ③宽度始终是与浏览器宽度一样，与内容无关； ④它可以容纳内联元素和其他块元素。
行内元素的特点：
①和其他元素都在一行上； ②高，行高及外边距和内边距部分可改变； ③宽度只与内容有关； ④行内元素只能容纳文本或者其他行内元素。 不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用， 只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用
内联元素（行内元素）(inline element) # a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量**</description></item><item><title>HTML解析过程</title><link>/fed-regain/html/html%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/html%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</guid><description>浏览器开始 # 这个过程可以结合NavigationTiming 来理解。具体流程如下图： 资源请求 # 浏览器第一步先请求资源，这过程和NavigationTiming中定义的一些关键时间节点类似，但有所区别。这块主要是在performance中[ResourceTiming][https://www.w3.org/TR/resource-timing/]规范定义的内容：
请求到资源之后，浏览器解析流程主要包含以下部分：
解析HTML，构建DOM树（这里遇到外链，此时会发起请求） 解析CSS，生成CSS规则树 合并DOM树和CSS规则，生成render树 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上 构建DOM # 浏览器请求一个url地址，然后通常web服务器会返回一个html页面，最先返回的就是html文件。 浏览器的HTML解释器获取到的首先是字节码，然后解析成对应字符序列。然后根据HTML解释器的DSL定义的tokens匹配解析成一个个html node节点，根据HTML语法定义的抽象语法树生成对应的树形结构（这期间html可能不规范，浏览器有很多容错机制来保证语法解析，参考嵌套约束），形成DOM树。
构建CSSOM # 浏览器加载CSS是同样的资源请求过程，请求后解析流程和HTML类似，CSS解释器会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。
需要注意的是：
每个浏览器都有自己默认的样式表 从右到左（内层到外）解析css 规则路径形成规则片段树，片段树集合形成CSSOM 构建RenderTree # DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似display: none;的不可见节点，在render过程中是会被跳过的（但visibility: hidden; opacity: 0这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。
串起来 # 当浏览器通过网络或者本地文件系统加载一个 HTML 文件，并对它进行解析完毕后，内核就会生成它最重要的数据结构 － DOM 树。DOM 树上每一个节点都对应着网页里面的每一个元素，并且网页也可以通过 JavaScript 操作这棵 DOM 树，动态改变它的结构。但是 DOM 树本身并不能直接用于排版和渲染，内核还会生成另外一棵树 － Render 树，Render 树上的每一个节点 － RenderObject，跟 DOM 树上的节点几乎是一一对应的，当一个可见的 DOM 节点被添加到 DOM 树上时，内核就会为它生成对应的 RenderOject 添加到 Render 树上。 Render 树是浏览器排版引擎的主要作业对象，排版引擎根据 DOM 树和 CSS 样式表的样式定义，按照预定的排版规则确定了 Render 树最后的结构，包括其中每一个 RenderObject 的大小和位置，而一棵经过排版的 Render 树，则是浏览器渲染引擎的主要输入，读者可以认为，Render 树是衔接浏览器排版引擎和渲染引擎之间的桥梁，它是排版引擎的输出，渲染引擎的输入。</description></item><item><title>HTML渲染过程</title><link>/fed-regain/html/html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</guid><description>一个 Chrome 浏览器一般会有一个 Browser 进程(运行UI线程、管理tab和运行插件线程等等的主进程)，一个 GPU 进程，和多个 Renderer 进程，通常每个 Renderer 进程对应一个页面。在特殊架构（Android WebView）或者特定配置下，Browser 进程可以兼作 GPU 进程或者 Renderer 进程（意味着没有独立的 GPU 或者 Renderer 进程），但是 Browser 跟 Renderer，Browser 跟 GPU，Renderer 跟 GPU 之间的系统架构和通讯方式基本保持不变，线程架构也是同样。参考这里：http://dev.chromium.org/developers/design-documents/multi-process-architecture
Blink 主要运行在 Renderer 进程的 Renderer 线程，我们通常会称之为内核主线程； Layer Compositor 主要运行在 Renderer 进程的 Compositor 线程； Display Compositor 主要运行在 Browser 进程的 UI 线程； 进程/线程架构 # Chromium拥有一套多进程架构。Chromium有一个浏览器进程和多个带有沙盒能力的渲染进程。Blink则运行在渲染进程中。
从安全的角度考虑，让不同的站点保持相互隔离是非常重要的，这被称作站点隔离（Site Isolation）。理论上讲，一个渲染进程应该最多只能负责一个站点的渲染工作。但实际上，当用户打开很多页签时，渲染进程与站点1对1的关系会占用大量的内存。所以一个渲染进程可能会被多个iframe或页签所共享，也就是说一个页面中的多个iframe可能被多个渲染进程渲染，而在不同页面中的多个iframe也可能被同一个渲染进程渲染。
所以，在iframe，页签和渲染进程间并不是简单的一对一的关系。
一个页面（Page）代表一个浏览器页签，一个渲染进程可能负责渲染多个页面。 一个框（Frame）代表主框或者一个iframe，一个页面至少包含一个框。 一个DOMWindow代表JavaScript中的window对象，每个框只有一个DOMWindow。 一个Document代表JavaScript中的window.document对象，每个框只有一个Document。 一个ExecutionContext在主线程中抽象一个Document，在worker线程中抽象WorkerGlobalScope。 渲染进程 ：页面 = 1 ：N 页面 ：框 = 1 ：M Frame : DOMWindow : Document (或ExecutionContext) 在任何情况下都是 1 : 1 : 1 ，但有时引用关系会变化。</description></item><item><title>页面生命周期</title><link>/fed-regain/html/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>导读 # 性能，一直都是前端孜孜不倦探讨的话题。说到生命周期想必大家都不陌生，这都是 React 、Vue 等框架设计的核心理念，它大致都提供了数据初始化、DOM 加载、资源释放等时机钩子供大家合理使用，例如 React shouldComponentUpdate 对某些场景下性能优化起着重要的作用。同理，生命周期的设计理念已被现代浏览器引入并实现，理解最新标准规范对前端理解性能优化的方向就变得很重要。本文主要介绍的内容有浏览器 Tab 页生命周期相关API，一些建议和对数据上报采集的实践等。
生命周期概述 # 好奇 # 谷歌等浏览器曾经被吐槽过是内存的吞鲸巨兽，但你有没有发现目前已被改善，当某个 Tab 长期未被激活，再次打开时发现页面会重新刷新。占用的资源是什么时候被回收的？
在移动设备上发现，浏览器被切换到后台时，网页上的一些任务会被降频（如 timer），甚至停止运行。浏览器是如何优化来减少内存、CPU、电量、网络资源的使用的？开发的哪些行为会干扰优化呢？
要弄懂这些问题就需要请出今天的主角—— W3C 最新的规范 Page Lifecycle。
解决的问题 # Page Lifecycle API 试图通过以下方式解决性能瓶颈：
在 Web 上引入并标准化生命周期状态的概念。 定义新的系统启动状态，允许浏览器限制隐藏或非激活选项卡可使用的资源。 创建新的 APIs 和事件，允许 Web 开发人员响应这些新的系统启动状态之间的转换。 该解决方案提供了Web 开发人员构建对系统干预具有弹性的应用程序所需的可预测性，并允许浏览器更积极地优化系统资源。
生命周期状态与事件 # 所有页面生命周期状态都是离散和互斥的，这意味着一个页面一次只能处于一个状态。
生命周期状态转变以及触发的事件 状态 描述 可能前一个的状态（触发事件） 可能下一个状态（触发事件） Active 页面可见document.visibilityState === 'visible' 并且有 input focus 1. passive (focus) 1. passive (blur) Passive 页面可见且没有input 处于 focus 1. active (blur)</description></item><item><title>Content-Security-Policy</title><link>/fed-regain/html/content-security-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/content-security-policy/</guid><description>首先我们要知道web浏览器为了安全都有会同源限制，什么是同源限制？就是来自 https://mybank.com 的代码应仅能访问 https://mybank.com 的数据，而绝不被允许访问 https://evil.example.com。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据，比如cookie/locaStoragy/IndexDB就遵守同源限制。XMLHettpRequest也是存在同源限制，相信只要开发过web的同学在ajax获取数据时都遇到过这个问题。
同源限制可以一定程度上限制我们的用户信息不会被盗取，但是却没法防止我们的页面被插入不法分子的资源（js，img，css等），毕竟页面上带src的元素资源是不受同源限制的。这些页面上的牛皮鲜让人很讨厌，影响是极其恶劣的：会让我们的js监控误报、会影响用户体验、甚至隐私泄露，所以我们需要对src资源也作出一定的限制，这就得Content-Security-Policy来了
Content-Security-Policy # Content-Security-Policy（内容安全政策,下文简称为CSP）,作用呢主要有两点：
使用白名单的方式告诉客户端（浏览器）允许加载和不允许加载的资源。 向服务器举报这种强贴牛皮鲜广告的行为，以便做出更加针对性的措施予以绝杀。 句法
Content-Security-Policy: &amp;lt;policy-directive&amp;gt;; &amp;lt;policy-directive&amp;gt; 举个配置的例子如下：
&amp;quot;Content-Security-Policy&amp;quot;:&amp;quot;default-src 'self' *.xx.com 'unsafe-inline' hybrid: data: wss:;img-src *&amp;quot; 怎么用 # 我们知道了好处还是很犀利的啊，这么好的东西怎么玩？其实也很简单，前面说到了他其实就是一个http header嘛，所以我们只需要在返回html页面的同时加上个response header 就行了，后面的script-src代表是一个指令，指示浏览器你只能加载我屁股后面那些规则下的js代码，其他的都一律拒绝。
Content-Security-Policy: script-src 'self' https://apis.google.com 关键字&amp;rsquo;self&amp;rsquo;：当前域名，需要加引号 也可以用meta &amp;lt;meta http-equiv=&amp;quot;Content-Security-Policy&amp;quot; content=&amp;quot;script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:&amp;quot;&amp;gt; 指令 # 前面说到script-src是一个指令，那就说明还有其他的指令罗，没有错，下面的都是指令，覆盖了web页面的所有资源
获取指令 # 提取指令控制可以加载某些资源类型的位置。
child-src定义Web工作人员的有效来源以及使用元素（例如frame和）加载的嵌套浏览上下文 iframe。
connect-src限制可以使用脚本接口加载的URL default-src用作其他提取指令的后备。
font-src指定使用加载的字体的有效来源@font-face。frame-src为使用元素（例如frame和）加载的嵌套浏览上下文指定有效来源iframe。
img-src指定图像和网站图标的有效来源。
manifest-src指定应用程序清单文件的有效来源。
media-src指定使用加载媒体来源有效audio，video和track元素。
object-src指定有效的来源object，embed和applet元素。
script-src指定JavaScript的有效来源。
style-src指定样式表的有效来源。
worker-src指定有效来源Worker，SharedWorker或ServiceWorker脚本。
文件指令 # Document指令控制策略适用的文档或工作环境的属性。</description></item><item><title>noopener和noreferrer</title><link>/fed-regain/html/noopener%E5%92%8Cnoreferrer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/noopener%E5%92%8Cnoreferrer/</guid><description>ESLint的确是个好东西，在使用airbnb的JavaScript语法校验工具时，如下的链接标签报出了安全错误： ​ 错误提示为Prevent usage of unsafe target=&amp;rsquo;_blank&amp;rsquo; (react/jsx-no-target-blank)，当我们希望使用target=_blank来打开一个新标签页时，一定要加上rel=&amp;lsquo;noreferrer noopener&amp;rsquo;，否则你的网页就会存在很严重的安全问题！！！
危险的target=&amp;rsquo;_blank&amp;rsquo; # ​ 假设在浏览A页面时，通过Click标签链接到了B页面，那么在B页面中通过window.reopner即可获取A页面的window对象，这样的话即可拿到部分的A页面的控制权，即使B页面是跨域的也可以拿到该控制权！
我们编写两个页面进行简单的测试，A页面（index.html）中有一个a标签，以及一个’待宰割‘的 Click：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;a href=&amp;quot;./test.html&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Click&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; B页面(test.html)中添加如下的js代码来试图篡改A页面：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Test page &amp;lt;script type=&amp;quot;application/javascript&amp;quot;&amp;gt; if (window.opener) { // opener.location = 'http://baidu.com' opener.document.getElementById('test').innerHTML = 'Now A page is revised!'; } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ​ 测试结果显示A页面标签被篡改了。该例子还只是简单的页面内容改动，但如果有人恶意的使用opener.location将A页面跳转到一个钓鱼网站，而此时用户的关注点还在B页面上，等用户返回’A页面’输入了隐私信息，那么后果不堪设想。
使用rel=noopener noreferrer # ​ 给标签添加rel=noopener可以使window.opener在Chrome 49 and Opera 36以上版本中为null。如果点击A页面上的链接跳转到了B页面，则称A页面为B页面的referrer（来源页面），通过referrer我们可以知道网站的流量从何而来。</description></item><item><title>preload和prefetch优化</title><link>/fed-regain/html/preload%E5%92%8Cprefetch%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/html/preload%E5%92%8Cprefetch%E4%BC%98%E5%8C%96/</guid><description>衡量网站的性能的指标有很多，其中有项重要的指标就是网站的首屏时间，为此前端工程师们都是绞尽脑汁想尽办法进行优化自己的应用，诸如像服务端渲染，懒加载，CDN 加速，ServiceWorker 等等方法，今天介绍的 preload/prefetch 是一种简单，但却事半功倍的优化手段。
基本用法 # 在网络请求中，我们在使用到某些资源比如：图片，JS，CSS 等等，在执行之前总需要等待资源的下载，如果我们能做到预先加载资源，那在资源执行的时候就不必等待网络的开销，这时候就轮到 preload 大显身手的时候了。
preload 提前加载 # preload 顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。
它可以通过 Link 标签进行创建：
&amp;lt;link rel=&amp;quot;preload&amp;quot; href=&amp;quot;/path/to/style.css&amp;quot; as=&amp;quot;style&amp;quot;&amp;gt; &amp;lt;script&amp;gt; const link = document.createElement(’link’); link.rel = ’preload’; link.as = ’style’; link.href = ’/path/to/style.css’; document.head.appendChild(link); &amp;lt;/script&amp;gt; 当浏览器解析到这行代码就会去加载 href 中对应的资源但不执行，待到真正使用到的时候再执行，另一种方式方式就是在 HTTP 响应头中加上 preload 字段：
Link: &amp;lt;https://example.com/other/styles.css&amp;gt;; rel=preload; as=style 这种方式比通过 Link 方式加载资源方式更快，请求在返回还没到解析页面的时候就已经开始预加载资源了。
讲完 preload 的用法再来看下它的浏览器兼容性，根据 caniuse.com 上的介绍：IE 和 Firefox 都是不支持的，兼容性覆盖面达到 73%。
prefetch 预判加载 # prefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源。它的用法跟 preload 是一样的：</description></item></channel></rss>