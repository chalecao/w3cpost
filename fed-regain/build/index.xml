<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>打包构建 on</title><link>/fed-regain/build/</link><description>Recent content in 打包构建 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:15 +0000</lastBuildDate><atom:link href="/fed-regain/build/index.xml" rel="self" type="application/rss+xml"/><item><title>asm.js 和 Emscripten 介绍</title><link>/fed-regain/build/asm-js-%E5%92%8C-emscripten-%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/asm-js-%E5%92%8C-emscripten-%E4%BB%8B%E7%BB%8D/</guid><description>2012年，Mozilla 的工程师 Alon Zakai 在研究 LLVM 编译器时突发奇想：许多 3D 游戏都是用 C / C++ 语言写的，如果能将 C / C++ 语言编译成 JavaScript 代码，它们不就能在浏览器里运行了吗？众所周知，JavaScript 的基本语法与 C 语言高度相似。
于是，他开始研究怎么才能实现这个目标，为此专门做了一个编译器项目 Emscripten。这个编译器可以将 C / C++ 代码编译成 JS 代码，但不是普通的 JS，而是一种叫做 asm.js 的 JavaScript 变体。
本文就将介绍 asm.js 和 Emscripten 的基本用法，介绍如何将 C / C++ 转成 JS。
一、asm.js 的简介 # 1.1 原理 # C / C++ 编译成 JS 有两个最大的困难。
C / C++ 是静态类型语言，而 JS 是动态类型语言。 C / C++ 是手动内存管理，而 JS 依靠垃圾回收机制。 **asm.js 就是为了解决这两个问题而设计的：它的变量一律都是静态类型，并且取消垃圾回收机制。**除了这两点，它与 JavaScript 并无差异，也就是说，asm.</description></item><item><title>babel涉及到的知识简单介绍</title><link>/fed-regain/build/babel%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/babel%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>引入 这个问题是对自己的发问，但我相信会有很多跟我一样的同学。
对于 babel 的使用，近半年来一直停留在与 webpack 结合使用，以及在浏览器开发环境下。导致很多 babel 的包，我都不清楚他们是干嘛的。比如 babel-register，还有 babel-runtime，各种 presets 的区别，transform-runtime 和 babel-polyfill 的区别，helpers 是干嘛的。尽管网上的 babel 的教程很多了，但是解答自己的一些疑问，还是要花费一些功夫。所以抽出时间来总结一下。如果你对于以上概念已经比较清楚了，就不需要往下看了。
版本变化 说实话，从我做前端的时候，接触 babel 的时候，就已经是 babel 6 了，但是这不妨碍了解一下它的重大版本变化。
上一个版本 babel 5 是全家桶，包括各种package， plugins，尽可能的想通过你的一次安装，达到全能的效果。不过你现在安装npm install babel，会得到一个 warning。babel 6 是 2015年10月30号发布，主要做了以下更新：
拆分成几个核心包，babel-core,babel-node,babel-cli&amp;amp;#8230; 没有了默认的转换，现在你需要手动的添加 plugin。也就是插件化 添加了 preset，也就是预置条件。 增加了 .babelrc 文件，方便自定义的配置。 差不多了，我感觉其他的也不需要了解了。
包 babel 里面有好多的包，所以必须搞清楚他们都是干嘛的，才能让我们更好的使用这个工具。
babel-core 可以看做 babel 的编译器。babel 的核心 api 都在这里面，比如 transform，主要都是处理转码的。它会把[我们](https://www.w3cdoc.com)的 js 代码，抽象成 ast，即 abstract syntax tree 的缩写，是源代码的抽象语法结构的树状表现形式。[我们](https://www.w3cdoc.com)可以理解为，它定义的一种分析 js 语法的树状结构。也就是说 es6 的新语法，跟老语法是不一样的，那[我们](https://www.w3cdoc.com)怎么去定义这个语法呢。所以必须要先转成 ast，去发现这个语法的 kind，分别做对应的处理，才能转化成 es5.</description></item><item><title>DllPlugin提升webpack编译</title><link>/fed-regain/build/dllplugin%E6%8F%90%E5%8D%87webpack%E7%BC%96%E8%AF%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/dllplugin%E6%8F%90%E5%8D%87webpack%E7%BC%96%E8%AF%91/</guid><description>一、前言 The DllPlugin and DllReferencePlugin provide means to split bundles in a way that can drastically improve build time performance.
DllPlugin结合DllRefrencePlugin插件的运用，对将要产出的bundle文件进行拆解打包，可以很彻底地加快webpack的打包速度，从而在开发过程中极大地缩减构建时间。
二、构建效果 结论先行：使用DllPlugin和DllRefrencePlugin进行构建，可以缩减50%～70%的构建时间。
参考Demo：dllplugin-demo
2.1 使用DllPlugin前的构建速度 入口文件main.js引入了一个jQuery文件，图示打包耗时2.3s。
2.2 使用DllPlugin后的构建速度 使用插件后，打包耗时0.6s，单次对比，缩减时长达到73%！
2.3 如何验证DLLPlugin已经生效 对比上面两张图打包的模块列表，图二有一行不一样的输出：
[0] delegated ./src/components/jquery.js from dll-reference vendor_57c12dcd8d9774596525 42 bytes {0} [built] 这说明，此次的打包过程，没有重新打包jQuery模块，而是直接从vendor_57c12dcd8d9774596525中代理了。
三、Get Started DllPlugin作用示意图：
3.1 配置webpack.dll.config.js打包静态公共资源 3.1.1 定义webpack.dll.config.js 为了减小篇幅，只帖关键配置内容，详细访问dllplugin-demo：
// webpack.dll.config.js module.exports = { entry: { // 定义程序中打包公共文件的入口文件vendor.js vendor: [path.resolve(src, 'js', 'vendor.js')], }, plugins: [ new webpack.</description></item><item><title>ES6模块打包工具—Rollup速览</title><link>/fed-regain/build/es6%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-rollup%E9%80%9F%E8%A7%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/es6%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-rollup%E9%80%9F%E8%A7%88/</guid><description>简介 # 以下内容基于Webpack和Rollup这两个打包工具来展开。
工具的使用是分场景的，Rollup的使用场景是，你的代码基于 ES6 模块编写，并且你做的东西是准备给他人使用的。
有一句经验之谈：在开发应用时使用 Webpack，开发库时使用 Rollup。
例如：React、Vue、Ember、Preact、D3、Three.js、Moment 等众多知名项目都使用了 Rollup
优点
编译运行出来的代码内容格式可读性好。 几乎没什么多余代码，除了必要的cjs, umd头外，bundle代码基本和源码没什么差异，没有奇怪的__webpack_require__, Object.defineProperty 相比Webpack，Rollup拥有无可比拟的性能优势，这是由依赖处理方式决定的，编译时依赖处理（Rollup）自然比运行时依赖处理（Webpack）性能更好,而且没什么多余代码，如上文提到的，webpack bundle不仅体积大，非业务代码（__webpack_require__, Object.defineProperty）执行耗时也不容小视。Rollup没有生成这些额外的东西，执行耗时主要在于Compile Script 和 Evaluate Script 上，其余部分可以忽略不计 支持ES6模块和IIFE格式。 对于ES6模块依赖库，Rollup会静态分析代码中的 import，并将排除任何未实际使用的代码。(Tree-shaking) 缺点
插件生态相对较弱，一些常见需求无法满足 比如打包多个依赖库，把公共依赖项提出来（Webpack的CommonsChunkPlugin）还有HMR(模块热替换)
文档相对较少，遇到问题无法快速解决 安装 # npm install -g rollup
全部指令 # Usage: rollup [options] &amp;lt;entry file&amp;gt;
Basic options:
-v, --version Show version number
-h, --help Show this help message
-c, --config Use this config file (if argument is used but value
is unspecified, defaults to rollup.</description></item><item><title>Grunt，Gulp工具</title><link>/fed-regain/build/gruntgulp%E5%B7%A5%E5%85%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/gruntgulp%E5%B7%A5%E5%85%B7/</guid><description>工具介绍 # 一个应用开发到一定阶段，普遍会遇到一个问题。当功能越来越多，代码量越来越大，bug修复越来越频繁，开发人员一波一波的交替，…..应该用会向着越来越不可控发展。我们不能再准确估计新功能的开发时间，也不知道一个bug修复后是否会引发另一个bug出现。所有的程序开发，都会面临着这样的问题。C/C++程序通过makefile管理编译测试打包的过程，Java程序通过Maven,Ant实现项目构建管理功能，Python有pip，Ruby有gem。在Nodejs的领域，我们同样需要一个项目构建工具。
本节主要介绍两种自动化构建工具，包括Grunt和Gulp，后续篇章中还会介绍bower包管理工具和Yeoman构建工具。这里先详细介绍这两种自动化构建工具，gulp.js 是一种基于流的，代码优于配置的新一代构建工具。Gulp 和 Grunt 类似。但相比于 Grunt 的频繁的 IO 操作，Gulp 的流操作，能更快地完成构建。
转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2014/08/18/2014_grunt_gulp/
Grunt配置及安装 # Grunt是一个自动化的项目构建工具. 如果你需要重复的执行像压缩, 编译, 单元测试, 代码检查以及打包发布的任务. 那么你可以使用Grunt来处理这些任务, 你所需要做的只是配置好Grunt, 这样能很大程度的简化你的工作.如果在团队中使用Grunt, 你只需要与其他人员约定好使用Grunt应该规避的问题, 就能够很方便的自动化的处理大部分的常见工作任务, 你所付出的努力几乎为0.
准备工作 # Grunt和相关插件是通过npm管理的，目前新版本是Grunt 0.4.x，要求NodeJS版本 &amp;gt; 0.8.0。安装之前请确保你的npm是最新的。可以通过
来升级。如果你安装了Grunt旧版本，先执行
然后安装grunt-cli，注意grunt-cli的作用是管理本地各版本的grunt，让命令行可以直接执行grunt命令，类似于grunt的客户端管理工具。
执行结果如下，我们看到grunt-cli似乎做了一个软件链接，把grunt脚本复制到nodejs安装根目录里。
安装Grunt之前，先要配置Grunt。 # 在项目根目录创建package.json 和 Gruntfile.js 文件，其中package.json 主要配置项目自动化所依赖的相关插件。Gruntfile.js 是项目自动化工作流配置文件，这个是grunt自动化构建的核心。然后在官网示例粘贴示例。
package.json 文件如下：
Gruntfile.js 文件修改如下：
相关介绍:
每个Gruntfile都有一个基本的格式，所有的Grunt代码都在这个函数中定义：
grunt.initConfig是一个初始化方法，有时候Grunt的任务会依赖某些配置文件，可以在这里初始化。比如本例中的_grunt.file.readJSON(‘package.json’)_就是导入了package.json中的配置参数，这个参数在后面的任务脚本中会用到。这里面同时定义了一个简单的uglify任务，通过src和dist指定该任务的源目录与目标目录。紧接着：
这个是插件声明。其他的任务像是 concatenation, minification and linting 都可以作为grunt的插件加载进来。
这一部分是自定义的人物组合，_default_是默认的参数，也就是输入grunt时会匹配该行任务，会执行_uglify_所定义的任务。其他的例如：
这个在执行grunt test时会自动匹配这个任务，执行相应的动作。
配置示例 # 按照上面的方法配置完之后，执行npm install会安装相应的依赖模块，然后可以输入_grunt_或者_grunt default_或者_grunt uglify_，三者的效果是一样的。
Grunt常用插件 # grunt-contrib-uglify：压缩js代码 grunt-contrib-concat：合并js文件 grunt-contrib-qunit：单元测试 grunt-contrib-jshint：js代码检查 grunt-contrib-watch：监控文件修改并重新执行注册的任务 grunt-contrib-concat # 如果你的package.</description></item><item><title>Gulp中的sprite图和mixin</title><link>/fed-regain/build/gulp%E4%B8%AD%E7%9A%84sprite%E5%9B%BE%E5%92%8Cmixin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/gulp%E4%B8%AD%E7%9A%84sprite%E5%9B%BE%E5%92%8Cmixin/</guid><description>介绍一下项目中用到的css3 mixin和自动打包雪碧图的类库
前端工作流：工具集总篇
spritesmith # 1.Generating CSS sprites with Gulp
gulp-spritesmith
gulp-css-spritesmith
Bourbon # Bourbon 是一个简单易用的 Sass 混入（Mixin）库，无需配置。该混入包含用于支持所有现代浏览器的 CSS3 属性前缀。前缀需要确保在旧的浏览器支持优雅降级。Bourbon 使用 SCSS 语法。
Bourbon 官网
谢谢！ # 转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2016/04/12/2016_gulp_mixin/
欢迎关注皓眸学问公众号（扫描左侧二维码），每天好文、新技术！任何学习疑问或者工作问题都可以给我留言、互动。T_T 皓眸大前端开发学习 T_T</description></item><item><title>npm shrinkwrap命令分析版本</title><link>/fed-regain/build/npm-shrinkwrap%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%E7%89%88%E6%9C%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/npm-shrinkwrap%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%E7%89%88%E6%9C%AC/</guid><description>npm采用语义化的版本号 semver 进行控制，让开发过程中依赖的获取和升级变得非常容易，但不严格的版本号控制，也带来了不确定性~~ &amp;lt;ul&amp;gt; npm 建议使用semver版本，部分包不遵循semver； package.json 可以使用精确的版本号控制你的直接依赖包，但第三方依赖的包无法管理； 在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。 目前主流的版本控制使用的是 semver 语义化版本。即，X.Y.Z （主版本号.次版本号.修订号） 主版本号：当你做了不兼容的 API 修改 次版本号：当你做了向下兼容的功能性新增 修订号：当你做了向下兼容的问题修正 也可以将先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。(v1.2.2-beta)
# 查看当前哪些包需要更新 $ npm outdated -g -depth=0 Package &amp;lt;th&amp;gt; Current &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Wanted &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Latest &amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt; webpack &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 4.6.0 &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 4.17.1 &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 4.17.1 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt; pm2 &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 2.6.1 &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 2.10.4 &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 3.0.4 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt; commitizen &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; 2.</description></item><item><title>React基于webpack做code splitting方法</title><link>/fed-regain/build/react%E5%9F%BA%E4%BA%8Ewebpack%E5%81%9Acode-splitting%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/react%E5%9F%BA%E4%BA%8Ewebpack%E5%81%9Acode-splitting%E6%96%B9%E6%B3%95/</guid><description>随着web应用功能越来越复杂，模块打包后体积越来越大，如何实现静态资源的按需加载，最大程度的减小首页加载模块体积和首屏加载时间，成为模块打包工具的必备核心技能。
webpack作为当下最为流行的模块打包工具，成为了react、vue等众多热门框架的官方推荐打包工具。其提供的Code Splitting（代码分割）特性正是实现模块按需加载的关键方式。
什么是Code Splitting # 官方定义：
Code splitting is one of the most compelling features of webpack. It allows you to split your code into various bundles which you can then load on demand — like when a user navigates to a matching route, or on an event from the user. This allows for smaller bundles, and allows you to control resource load prioritization, which if used correctly, can have a major impact on your application load time</description></item><item><title>tree shaking介绍</title><link>/fed-regain/build/tree-shaking%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/tree-shaking%E4%BB%8B%E7%BB%8D/</guid><description>Tree-Shaking性能优化实践 - 原理篇 一. 什么是Tree-shaking 先来看一下Tree-shaking原始的本意 &amp;lt;img class=&amp;quot;lazyload inited loaded&amp;quot; src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/06/160bfdcf2a31ce4a.gif&amp;quot; data-src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/06/160bfdcf2a31ce4a.gif?x-oss-process=image/format,webp&amp;quot; data-src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/06/160bfdcf2a31ce4a.gif&amp;quot; data-width=&amp;quot;606&amp;quot; data-height=&amp;quot;341&amp;quot; /&amp;gt; &amp;lt;/div&amp;gt; 上图形象的解释了Tree-shaking 的本意，本文所说的[前端](https://www.w3cdoc.com)中的tree-shaking可以理解为通过工具&amp;#8221;摇&amp;#8221;[我们](https://www.w3cdoc.com)的JS文件，将其中用不到的代码&amp;#8221;摇&amp;#8221;掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。 &amp;lt;img loading=&amp;quot;lazy&amp;quot; width=&amp;quot;720&amp;quot; height=&amp;quot;405&amp;quot; class=&amp;quot;alignnone size-full wp-image-4903 shadow&amp;quot; src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee0587e76.png&amp;quot; data-src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee0587e76.png?x-oss-process=image/format,webp&amp;quot; alt=&amp;quot;&amp;quot; srcset=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee0587e76.png?x-oss-process=image/format,webp 720w, https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee0587e76.png?x-oss-process=image/quality,q_50/resize,m_fill,w_300,h_169/format,webp 300w&amp;quot; sizes=&amp;quot;(max-width: 720px) 100vw, 720px&amp;quot; /&amp;gt; &amp;lt;/div&amp;gt; Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。 二. tree-shaking的原理 &amp;lt;img loading=&amp;quot;lazy&amp;quot; width=&amp;quot;720&amp;quot; height=&amp;quot;405&amp;quot; class=&amp;quot;alignnone size-full wp-image-4904 shadow&amp;quot; src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee165a0d3.png&amp;quot; data-src=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee165a0d3.png?x-oss-process=image/format,webp&amp;quot; alt=&amp;quot;&amp;quot; srcset=&amp;quot;https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee165a0d3.png?x-oss-process=image/format,webp 720w, https://haomou.oss-cn-beijing.aliyuncs.com/upload/2019/08/img_5d4aee165a0d3.png?x-oss-process=image/quality,q_50/resize,m_fill,w_300,h_169/format,webp 300w&amp;quot; sizes=&amp;quot;(max-width: 720px) 100vw, 720px&amp;quot; /&amp;gt; Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。 Tree-shaking 是 DCE 的一种新的实现，Javascript同传统的编程语言不同的是，javascript绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对javascript来说更有意义。</description></item><item><title>Webpack模块加载神器</title><link>/fed-regain/build/webpack%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%A5%9E%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/build/webpack%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%A5%9E%E5%99%A8/</guid><description>什么是Webpack # Webpack 是德国开发者 Tobias Koppers 开发的模块加载器。Instagram 工程师认为这个方案很棒, 似乎还把作者招过去了。在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等..因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl。对应各种不同文件类型的资源, Webpack 有对应的模块 loader, 比如 CoffeeScript 用的是 coffee-loader, 其他还有很多:https://webpack.github.io/docs/list-of-loaders.html
大致的写法也就这样子:
CommonJS 与 AMD 支持 # Webpack 对 CommonJS 的 AMD 的语法做了兼容, 方便迁移代码。不过实际上, 引用模块的规则是依据 CommonJS 来的
AMD 语法中, 也要注意, 是按 CommonJS 的方案查找的:
特殊模块的Shim # 比如某个模块依赖 window.jQuery, 需要从 npm 模块中将 jquery 挂载到全局。Webpack 有不少的 Shim 的模块, 比如 expose-loader 用于解决这个问题，https://github.com/webpack/docs/wiki/shimming-modules，其他比如从模块中导出变量…具体说明有点晦涩..
手头的两个例子, 比如我们用到 Pen 这个模块,这个模块对依赖一个 window.</description></item></channel></rss>