<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-500.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><link rel=stylesheet href=/main.f9552544b4ca62af741c0d24d283b4ddcfa2a026a871cff4112743eeb6c4950a530c923242d9d4d42e93635dd91ebd78601a145b8b205bb363d7065c1fa59ffe.css integrity="sha512-+VUlRLTKYq90HA0k0oO03c+ioCaocc/0ESdD7rbElQpTDJIyQtnU1C6TY13ZHr14YBoUW4sgW7Nj1wZcH6Wf/g==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>校招社招必备核心面试问题与详细解答 - 万维刀客「w3cdoc」</title><meta name=description content="本文总结了前端老司机经常问题的一些问题并结合个人总结给出了比较详尽的答案。网易阿里腾讯校招社招必备知识点。
原理讲解参考：[前端增长-重新定义大前端]1
前端基础知识视频讲解：网易云课堂课程 思否segment课堂
1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？ # 浏览器是按照文档流解析html，为了更快构建DOM树和渲染树将页面呈现到屏幕上，建议是降js放在文档dom树结尾，body标签闭合前。 浏览器并发HTTP请求有限制（6个左右），加载页面html后开始解析，解析到外链资源比如js css和图片，就会发http请求获取对应资源。减少请求就是减少这些资源请求, 可以 css资源合并，js资源合并，图片资源合并同时做lazyload，区分首屏非首屏接口，按需请求数据。 雪碧图是一种图片资源的合并方法，将一些小图片合成一张图，通过background-position来定位到对应部分。 window.performance.timing 参考下[前端页面性能指标数据计算方法]2, performance接口属于w3c标准hight resolution time中的一部分，通过navigation timeline api 、 performance timeline api，user timing api，resource timeline api 这四个接口做了增强实现。其中navigation timeline api中PerformanceTiming 接口数据放在 performance.timing这个对象上。主要记录了浏览器从跳转开始的各个时间点的时间，比如navigationStart是页面开始跳转时间，fetchStart是页面开始时间，domainLookupStart是DNS开始时间，domainLookupEnd是DNS结束时间， 查找到DNS后建立http链接，connectStart和connectEnd分别是链接开始和结束时间，然后是requestStart开始发起请求时间，responseStart开始响应时间，responseEnd响应结束时间。然后是苟安DOM树时间，分别是domLoading, domInteractive, domContentLoad和domComplete时间，分别对应document.readyState状态loading、interactive和complete。最后是页面onload，分别是loadEventStart和loadEventEnd时间节点。 可以通过这个接口统计前端的页面性能数据。
domainLookupStart - fetchStart = appCache时间，这段时间浏览器首先检查缓存 domainLookupEnd -domainLookupStart = DNS时间 connectEnd - connectStart = TCP时间 responseStart - requestStart = FTTB首字节时间，或者说是服务器响应等待时间 domContentLoad - navigationStart = 页面pageLoad时间 loadEventEnd - navigationStart = 页面onLoad时间 2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，浏览器的运行机制是什么，什么是否会造成渲染阻塞？ # 参考下：[浏览器工作原理]4 [浏览器渲染与阻塞原理]5"><link rel=canonical href=/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="校招社招必备核心面试问题与详细解答"><meta property="og:description" content="本文总结了前端老司机经常问题的一些问题并结合个人总结给出了比较详尽的答案。网易阿里腾讯校招社招必备知识点。
原理讲解参考：[前端增长-重新定义大前端]1
前端基础知识视频讲解：网易云课堂课程 思否segment课堂
1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？ # 浏览器是按照文档流解析html，为了更快构建DOM树和渲染树将页面呈现到屏幕上，建议是降js放在文档dom树结尾，body标签闭合前。 浏览器并发HTTP请求有限制（6个左右），加载页面html后开始解析，解析到外链资源比如js css和图片，就会发http请求获取对应资源。减少请求就是减少这些资源请求, 可以 css资源合并，js资源合并，图片资源合并同时做lazyload，区分首屏非首屏接口，按需请求数据。 雪碧图是一种图片资源的合并方法，将一些小图片合成一张图，通过background-position来定位到对应部分。 window.performance.timing 参考下[前端页面性能指标数据计算方法]2, performance接口属于w3c标准hight resolution time中的一部分，通过navigation timeline api 、 performance timeline api，user timing api，resource timeline api 这四个接口做了增强实现。其中navigation timeline api中PerformanceTiming 接口数据放在 performance.timing这个对象上。主要记录了浏览器从跳转开始的各个时间点的时间，比如navigationStart是页面开始跳转时间，fetchStart是页面开始时间，domainLookupStart是DNS开始时间，domainLookupEnd是DNS结束时间， 查找到DNS后建立http链接，connectStart和connectEnd分别是链接开始和结束时间，然后是requestStart开始发起请求时间，responseStart开始响应时间，responseEnd响应结束时间。然后是苟安DOM树时间，分别是domLoading, domInteractive, domContentLoad和domComplete时间，分别对应document.readyState状态loading、interactive和complete。最后是页面onload，分别是loadEventStart和loadEventEnd时间节点。 可以通过这个接口统计前端的页面性能数据。
domainLookupStart - fetchStart = appCache时间，这段时间浏览器首先检查缓存 domainLookupEnd -domainLookupStart = DNS时间 connectEnd - connectStart = TCP时间 responseStart - requestStart = FTTB首字节时间，或者说是服务器响应等待时间 domContentLoad - navigationStart = 页面pageLoad时间 loadEventEnd - navigationStart = 页面onLoad时间 2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，浏览器的运行机制是什么，什么是否会造成渲染阻塞？ # 参考下：[浏览器工作原理]4 [浏览器渲染与阻塞原理]5"><meta property="og:url" content="/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="og:site_name" content="万维刀客「w3cdoc」"><meta property="og:image" content="/doks.png"><meta property="og:image:alt" content="万维刀客「w3cdoc」"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@w3cdoc"><meta name=twitter:creator content="@chalecao"><meta name=twitter:title content="校招社招必备核心面试问题与详细解答"><meta name=twitter:description content><meta name=twitter:image content="/doks.png"><meta name=twitter:image:alt content="校招社招必备核心面试问题与详细解答"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"/#/schema/organization/1","name":"w3cdoc","url":"/","sameAs":["https://twitter.com/w3cdoc"],"logo":{"@type":"ImageObject","@id":"/#/schema/image/1","url":"/w3cdoc.png","width":512,"height":512,"caption":"w3cdoc"},"image":{"@id":"/#/schema/image/1"}},{"@type":"WebSite","@id":"/#/schema/website/1","url":"/","name":"万维刀客「w3cdoc」","description":"互联网同学互相帮助、学习成长的家园","publisher":{"@id":"/#/schema/organization/1"}},{"@type":"WebPage","@id":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","url":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","name":"校招社招必备核心面试问题与详细解答","description":"","isPartOf":{"@id":"/#/schema/website/1"},"about":{"@id":"/#/schema/organization/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"]}]},{"@type":"BreadcrumbList","@id":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"/","url":"/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"/fed-regainthink%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/#/schema/image/2","url":"/doks.png","contentUrl":"/doks.png","caption":"校招社招必备核心面试问题与详细解答"}]}]}</script><meta name=theme-color content="#fff"><link rel=icon href=/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/sw.js",{scope:"/"}).then(function(e){console.log("Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("Registration failed with "+e)})</script><script src=/js/vendor/autolog.js async></script></head><body class="fed-regain single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/ aria-label=万维刀客「w3cdoc」>万维刀客「w3cdoc」</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>万维刀客「w3cdoc」</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>初级入门
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/js/basic/javascript%E4%BB%8B%E7%BB%8D/>JS入门</a></li><li><a class=dropdown-item href=/git/basic/introduction/>Git入门</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>进阶学习
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/fed-regain/html/html%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/>前端增长</a></li><li><a class=dropdown-item href=/webgl/base/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/>3D图形</a></li><li><a class=dropdown-item href=/bigdata/compute/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/>数据分析</a></li></ul></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/blog/>博客</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/course/>网课教程</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><form class="doks-search position-relative flex-grow-1 ms-lg-auto me-lg-2"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"></ul><hr class="text-black-50 my-4 d-lg-none"><button id=mode class="btn btn-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></div></div></nav></header></div><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-fc35fdc70d5fc69d269883a822c7a53e aria-expanded=false>
html</button><div class=collapse id=section-fc35fdc70d5fc69d269883a822c7a53e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/html/html%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/>HTML发展历史</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97%E7%BA%A6%E6%9D%9F/>HTML元素嵌套约束</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/>HTML解析过程</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/>HTML渲染过程</a></li><li><a class="docs-link rounded" href=/fed-regain/html/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/>页面生命周期</a></li><li><a class="docs-link rounded" href=/fed-regain/html/content-security-policy/>Content-Security-Policy</a></li><li><a class="docs-link rounded" href=/fed-regain/html/noopener%E5%92%8Cnoreferrer/>noopener和noreferrer</a></li><li><a class="docs-link rounded" href=/fed-regain/html/preload%E5%92%8Cprefetch%E4%BC%98%E5%8C%96/>preload和prefetch优化</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-c7a628cba22e28eb17b5f5c6ae2a266a aria-expanded=false>
css</button><div class=collapse id=section-c7a628cba22e28eb17b5f5c6ae2a266a><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/css/css%E7%9A%84%E5%8F%91%E5%B1%95/>CSS的发展</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E4%BA%A4%E4%BA%92/>CSS交互</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E5%8F%98%E9%87%8F/>CSS变量</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E5%9F%BA%E7%BA%BF%E4%B8%8E%E8%A1%8C%E9%AB%98%E5%85%B3%E7%B3%BB/>css基线与行高关系</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97/>CSS选择器性能损耗</a></li><li><a class="docs-link rounded" href=/fed-regain/css/font-face%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/>font-face需要知道的一切</a></li><li><a class="docs-link rounded" href=/fed-regain/css/media-type-%E4%B8%8Emedia-query/>media type 与media query</a></li><li><a class="docs-link rounded" href=/fed-regain/css/minmax%E5%92%8Cclamp%E4%B8%89%E4%B8%AA%E9%80%BB%E8%BE%91/>minmax和clamp三个逻辑</a></li><li><a class="docs-link rounded" href=/fed-regain/css/containingblock/>什么是containing block？</a></li><li><a class="docs-link rounded" href=/fed-regain/css/content-visibility/>content-visibility</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E6%96%87%E6%9C%AC%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%E7%AD%89/>文本均匀分布两端对齐等</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%94%A8%E6%B3%95/>伪类与伪元素的用法</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E5%9B%BE%E7%89%87%E9%93%BA%E6%BB%A1%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%8F%98%E5%BD%A2/>图片铺满展示不变形</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E4%BD%BF%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%E6%97%81%E9%97%A8%E5%B7%A6%E9%81%93/>使元素不可见的旁门左道</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E7%90%86%E8%A7%A3css%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8A%A8%E7%94%BB%E8%B0%83%E8%AF%95/>理解CSS动画性能问题与动画调试</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E9%AB%98%E6%80%A7%E8%83%BDcss%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/>高性能CSS动画总结</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E5%8F%98%E6%80%81android%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/>变态android文字垂直居中</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-32981a13284db7a021131df49e6cd203 aria-expanded=false>
js</button><div class=collapse id=section-32981a13284db7a021131df49e6cd203><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-055823d5251a151ba2621eab0cb94843 aria-expanded=false>
js基础</button><div class=collapse id=section-055823d5251a151ba2621eab0cb94843><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/base/varletconst%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E5%9F%9F/>var、let、const及其作用域</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A4%9A%E8%A1%8C%E8%B6%85%E5%87%BA%E5%B0%BE%E9%83%A8%E5%B1%95%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E6%94%B9%E8%BF%9B/>多行超出尾部展示省略号</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8/>二进制运算符使用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/typescript%E5%88%9D%E5%AD%A6%E4%BA%86%E8%A7%A3/>TypeScript初学了解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BD%BF%E7%94%A8fetch%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%99%E8%AF%AF/>工程师使用fetch常见的四种错误</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E6%9E%84%E5%BB%BAdom%E5%92%8Ccssom/>构建DOM和CSSOM</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E4%BA%8B%E4%BB%B6%E6%B5%81/>JavaScript事件流</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%85%B3%E4%BA%8Eajax%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/>关于ajax请求头设置</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3call/>函数调用的角度理解call</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%9F%BA%E4%BA%8Etypescript%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAnpm%E5%8C%85/>基于typescript开发一个npm包</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>简单的事件监听处理函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/>跨域和常用方法</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BA%86%E8%A7%A3%E4%B8%8Bpromise-a%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0promise/>了解下Promise A+规范，实现Promise</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%88%A4%E6%96%AD%E5%86%85%E5%AE%B9%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8/>判断内容区域是否滚动到底部</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%A7%A6%E6%91%B8%E5%8A%A8%E4%BD%9C/>如何高效响应用户触摸动作</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3function/>如何理解function</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8-service-workers%E6%8F%90%E5%8D%87%E4%BD%93%E9%AA%8C/>使用 Service Workers提升体验</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E5%92%8Cjsdoc%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E8%A7%84%E8%8C%83/>使用注释和JSDOC让代码更规范</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8settimeout%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E5%92%8Csetinterval%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/>使用setTimeout循环调用和setInterval有什么区别</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B9%8Bpromise%E5%AF%B9%E8%B1%A1/>异步回调之Promise对象</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%8E%9F%E7%94%9Flazyloadcsp%E5%92%8Cdeno/>原生lazyload、csp和deno</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/typescript%E5%A4%A7%E6%B3%95/>typescript大法</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E8%A3%85/>原型，原型链，继承与组装</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE/>ES6常用语法回顾</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es2016%E8%A3%85%E9%A5%B0%E5%99%A8/>ES2016装饰器</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/globalwindowdocument-%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/>Global\window\document 简单说明</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/iframe%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>iframe的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/immutable%E8%AF%A6%E8%A7%A3/>IMMUTABLE 详解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>JavaScript跨域请求的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/>Javascript垃圾回收浅析</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>Javascript内存管理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%AE%9E%E7%8E%B0jsonp%E5%92%8Cajax/>JavaScript实现JSONP和ajax</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/jquery%E7%AC%94%E8%AE%B0deferred/>jquery笔记deferred</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/webstorge%E4%BD%BF%E7%94%A8/>WebStorge使用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/js%E5%8E%9F%E7%94%9F%E7%BC%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0/>JS原生编解码函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/js%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/>JS中浮点数精度问题</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/jsonp%E8%80%8C%E4%B8%8D%E6%98%AFajax/>jsonp而不是AJAX？</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E4%B8%8Easync/>script标签的defer与async</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/script%E6%A0%87%E7%AD%BE%E6%B7%BB%E5%8A%A0crossorigin/>script标签添加crossorigin</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/too-many-pausable-objects/>Too many Pausable Objects</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/touch%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8Eclick/>touch点击穿透与click与300ms延迟</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es6-%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86/>ES6 … 拆箱与装箱实现深克隆</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86/>浅克隆与深克隆</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b30ced48d20f44561d96d291478acbd8 aria-expanded=false>
js高级</button><div class=collapse id=section-b30ced48d20f44561d96d291478acbd8><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%8F%90%E5%8D%87%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/>执行上下文和提升与事件循环</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/object-defineproperty%E4%B8%8Eproxy/>Object.defineProperty与Proxy</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E8%AF%A6%E8%A7%A3object-createnull%E5%92%8Cnew%E5%8C%BA%E5%88%AB/>详解Object.create(null)和new区别</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%9F%BA%E4%BA%8Ees6%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/>基于ES6标签模板实现事件绑定与数据监听</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%86if%E5%9D%97/>函数式编程处理IF块</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/>JS对象属性的快速删除</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E7%89%B9%E6%80%A7%E6%80%A7%E8%83%BD%E7%BC%BA%E9%99%B7%E5%8F%8Ajit%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/>JS特性性能缺陷及JIT的解决方案</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%AF%B9%E8%B1%A1%E5%9C%A8-v8-%E5%86%85%E7%9A%84%E8%A1%A8%E8%BE%BE/>JS对象在 V8 内的表达</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%A4%A7%E8%AF%9Djavascript-%E5%BC%95%E6%93%8E%E6%89%AB%E7%9B%B2%E7%AF%87/>大话JavaScript 引擎扫盲篇</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%9E%84%E5%BB%BAjavascript-%E6%B2%99%E7%AE%B1/>构建JavaScript 沙箱</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/>关于对象的访问优化</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%85%B3%E4%BA%8Ehit-test/>关于hit test</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/>控制反转和依赖注入</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/react-shadow/>react shadow</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/shadow-dom%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/>Shadow DOM简单了解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/json-ld/>json-ld的用处</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E5%92%8Ccss%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E9%97%AE%E9%A2%98/>JS和CSS使用的一些小技巧和问题</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-43e6bf76b53ba4d9ffc765bf79022281 aria-expanded=false>
js框架</button><div class=collapse id=section-43e6bf76b53ba4d9ffc765bf79022281><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/framework/amd%E4%B8%8Ecmd%E8%A7%84%E8%8C%83-javascript%E6%A8%A1%E5%9D%97%E5%8C%96/>AMD与CMD规范-javascript模块化</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/bsrssgssr%E4%B9%8Bnext-js/>BSR、SSG、SSR之next.js</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/hooks%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/>hooks使用指南</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>JavaScript函数式编程</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/reactfiber%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/>react fiber怎么回事</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E5%AE%8C%E5%85%A8%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8C%97/>React Hooks完全上手指北</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E6%A8%A1%E6%8B%9F%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/>react hooks模拟各个生命周期函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E7%9A%84%E5%BA%94%E7%94%A8/>react hooks的应用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hook%E7%9A%84%E5%88%9D%E6%AD%A5%E7%A0%94%E7%A9%B6%E5%89%8D%E8%A8%80renderwithhooks%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B/>react hook的初步研究前言renderWithHooks的整个过程</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-shadow/>react shadow</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/>react事件系统</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/>react阻止事件冒泡失败原因</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/svelte%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E6%80%A7%E5%8E%9F%E7%90%86/>Svelte框架的特性原理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/>vue3中的响应式原理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/>Vue3响应式原理整理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue%E4%B8%8Eangular%E4%B8%8Ereact/>vue与angular与react</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue%E4%B8%AD8%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/>vue中8种组件通信方式</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/webcomponents%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/>web components入门与实践</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%9F%BA%E4%BA%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%86%99%E4%B8%80%E4%B8%AAeventemitter/>基于发布订阅模式写一个eventEmitter</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99vscode-extension%E6%8F%92%E4%BB%B6/>如何编写vscode extension插件</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%B0%86react%E5%BD%93%E5%81%9A%E5%89%8D%E7%AB%AFui%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E6%9D%A5%E7%9C%8B%E5%BE%85/>将React当做[前端](https://www.w3cdoc.com)UI运行时环境来看待</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/>工作流引擎比较规则引擎</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E4%B9%8Bvm%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/>数据监听之VM原理分析与实现</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E7%94%A8javascript%E8%87%AA%E5%B7%B1%E5%86%99virtual-dom/>用JavaScript自己写Virtual DOM</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/>自己写个前端路由</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/>路由原理和实现</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%BD%ACreact-redux%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E6%9C%80%E6%98%93%E6%87%82%E7%9A%84%E8%AF%B4%E6%98%8E/>转:react-redux原理介绍，最易懂的说明</a></li></ul></div></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-82d4d1dc1b6fc48a08a1c8c2a4b805ec aria-expanded=false>
svg和canvas</button><div class=collapse id=section-82d4d1dc1b6fc48a08a1c8c2a4b805ec><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/canvas%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E4%B8%8E%E5%8A%A8%E7%94%BB/>canvas图片处理与动画</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/canvas%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%92%8C%E6%BB%A4%E9%95%9C%E7%89%B9%E6%95%88/>Canvas图像处理和滤镜特效</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E6%9B%BE%E7%BB%8F%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/>曾经基于canvas实现的飞机大战</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/fabric-js%E4%B9%8B%E5%BC%B7%E5%A4%A7%E7%9A%84svg%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/>fabric.js之強大的SVG处理工具类库</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/offscreencanvas-%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/>OffscreenCanvas – 概念说明及使用解析</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E6%96%B0%E6%80%9D%E8%B7%AF/>SVG压缩与字体图标新思路</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E5%B5%8C%E5%A5%97%E8%A7%86%E7%AA%97%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B/>SVG嵌套视窗综合实例</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%9A%84%E7%89%9Bb%E4%B9%8B%E5%A4%84%E4%BD%A0%E9%80%A0%E5%90%97/>SVG的牛B之处，你造吗</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%9A%84%E8%A7%86%E7%AA%97%E4%B8%8E%E5%AE%BD%E9%AB%98%E6%AF%94%E6%8E%A7%E5%88%B6/>SVG的视窗与宽高比控制</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%BC%A9%E6%94%BE%E7%A7%BB%E5%8A%A8%E5%80%BE%E6%96%9C%E5%92%8C%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/>SVG缩放，移动，倾斜和旋转变换</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%E7%9A%84%E6%96%B9%E6%A1%88/>实现路径动画SMIL或offset-path和canvas</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-svg-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%8D%A0%E4%BD%8D%E7%AC%A6/>怎么使用 SVG 作为一个图像占位符</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-57f62e085cfdf20b39e12de8b1993112 aria-expanded=false>
dsl</button><div class=collapse id=section-57f62e085cfdf20b39e12de8b1993112><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/dsl/js%E6%A8%A1%E6%8B%9F%E7%BA%A2%E7%99%BD%E6%9C%BAjsnes%E4%BB%BB%E5%A4%A9%E5%A0%82%E6%B8%B8%E6%88%8F%E6%9C%BA/>js模拟红白机jsnes任天堂游戏机</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/sketch%E6%80%8E%E4%B9%88%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/>Sketch怎么开发插件</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E5%9F%BA%E4%BA%8Econfig-form%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/>基于config-form转向面向数据的编程</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E6%9E%84%E5%BB%BAc%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E8%B0%83%E7%A0%94/>构建C语言解释执行环境调研</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E6%B5%81%E7%A8%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/>流程驱动设计研发实战</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-db06c78d1e24cf708a14ce81c9b617ec aria-expanded=false>
测试</button><div class=collapse id=section-db06c78d1e24cf708a14ce81c9b617ec><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/test/%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/>可用性测试</a></li><li><a class="docs-link rounded" href=/fed-regain/test/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7mocha-in-browser/>开发测试工具mocha-in-browser</a></li><li><a class="docs-link rounded" href=/fed-regain/test/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95+%E5%B7%A5%E5%85%B7/>测试方法+工具</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b7c0bfff1b6f1cc255716a1cb8b68011 aria-expanded=false>
调试</button><div class=collapse id=section-b7c0bfff1b6f1cc255716a1cb8b68011><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/debug/%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7weinre-2/>手机网页调试工具weinre</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-912302cb020149c37f9642fbc9e42891 aria-expanded=false>
浏览器</button><div class=collapse id=section-912302cb020149c37f9642fbc9e42891><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-9aa9f3eb840e2278563d9b10a2642144 aria-expanded=false>
HTTP协议</button><div class=collapse id=section-9aa9f3eb840e2278563d9b10a2642144><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/browser/http/http-2-%E4%B8%8E-web-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>HTTP/2 与 WEB 性能优化</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/https%E8%AE%BF%E9%97%AElocalhost%E7%9A%84http%E8%B5%84%E6%BA%90/>HTTPS访问localhost的http资源</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98vs%E5%BC%BA%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/>HTTP协商缓存VS强缓存原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8Ahttp2-0-1-1-1-0%E5%8C%BA%E5%88%AB/>HTTP协议以及HTTP2.0/1.1/1.0区别</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/websocket%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/>websocket建立连接</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E9%80%81options%E8%AF%B7%E6%B1%82/>什么时候会发送options请求</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E5%85%B3%E4%BA%8Echrome%E8%AF%B7%E6%B1%82stalled%E7%9A%84%E6%97%B6%E9%97%B4/>关于chrome请求stalled的时间</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http-proxy/>基于正向代理解决方案实现的万能代理接口代理转发服务</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97-websocket%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E5%B0%8F%E6%B8%B8%E6%88%8F/>移动[前端](https://www.w3cdoc.com)系列——websocket实时互动小游戏</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E8%AF%B4%E8%AF%B4http%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%A6%99%E7%94%A8/>说说http状态码和妙用</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-e747eaca8d3884c2069788c67e22910e aria-expanded=false>
多端兼容性</button><div class=collapse id=section-e747eaca8d3884c2069788c67e22910e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/h5%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>H5兼容性问题总结</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/ios%E4%BD%8E%E7%89%88%E6%9C%AC%E4%B8%ADjavascript%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/>ios低版本中JavaScript的兼容性问题</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/iphone6%E5%92%8C6s%E4%B8%ADwebview%E7%9A%84bug/>iphone6和6s中webview的bug</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/%E5%9F%BA%E4%BA%8Erem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/>基于rem方案实现自适应布局</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/>手机网页开发问题集锦</a></li></ul></div></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome-79%E9%BB%98%E8%AE%A4%E6%89%A7%E8%A1%8Csamesite-by-default%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%90%BA%E5%B8%A6cookie/>Chrome 79+默认执行SameSite-by-default，跨域请求默认不携带cookie</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E5%BC%80%E5%A7%8B%E9%9B%86%E6%88%90%E5%9B%BE%E5%BD%A2%E8%AF%86%E5%88%AB-apishape-detection-api/>Chrome开始集成图形识别 API（Shape Detection API）</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/>chrome插件开发</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8Eblinkv8/>Chrome浏览器引擎Blink&V8</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/provisional-headers-are-shown%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95/>Provisional headers are shown？怎么调试</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/webrtc%E7%9B%B8%E5%85%B3%E7%9A%84canvas%E4%B8%8Evideo/>WebRTC相关的canvas与video</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8web%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86/>浏览器JS引擎工作原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Enode%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/>浏览器与node环境的事件循环机制</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/>浏览器前进后退的缓存机制</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>浏览器工作原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E9%98%BB%E5%A1%9E%E5%8E%9F%E7%90%86/>浏览器渲染与阻塞原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BD%91%E9%A1%B5%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>浏览器渲染流水线解析与网页动画性能优化</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3%E4%B8%8Emicrotask%E4%B8%8Emacrotask/>浏览器线程理解与microtask与macrotask</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95/>浏览器默认超时时间测试</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E7%AE%80%E8%BF%B0chromium-cef-webkit-javascriptcore-v8-blink/>简述Chromium, CEF, Webkit, JavaScriptCore, V8, Blink</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E7%AE%A1%E7%90%86history%E4%B9%8Bpushstatereplacestate/>管理history之pushState、replaceState</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86%E6%A0%88/>虚拟机的堆和栈与数据结构堆栈</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-9214d980933ae261b589eaefbd7d256d aria-expanded=false>
微前端</button><div class=collapse id=section-9214d980933ae261b589eaefbd7d256d><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%9F%BA%E4%BA%8Econfig-component%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/>基于config-component转向面向数据的编程</a></li><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%9F%BA%E4%BA%8Ewebcomponents%E7%9A%84%E5%AE%9E%E7%8E%B0/>基于webcomponents的实现</a></li><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/>微前端架构的一些想法</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b0f31b26d51a7233ea004c63cb714f7f aria-expanded=false>
性能体验</button><div class=collapse id=section-b0f31b26d51a7233ea004c63cb714f7f><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-f36dd17540804d4b2c456780caab0a2d aria-expanded=false>
性能体验埋点</button><div class=collapse id=section-f36dd17540804d4b2c456780caab0a2d><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E6%80%BB%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4tbt/>“总阻塞时间”（TBT）</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/elasticsearch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/>Elasticsearch入门学习</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/lcptbt%E4%B8%8Ecls%E6%8C%87%E6%A0%87/>LCP、TBT与CLS指标</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E4%BA%86%E8%A7%A3filebeat%E5%92%8C%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/>了解Filebeat和使用配置</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E6%9C%80%E5%A4%A7%E5%86%85%E5%AE%B9%E7%BB%98%E7%94%BBlcp/>最大内容绘画（LCP）</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E7%B4%AF%E7%A7%AF%E7%89%88%E5%BC%8F%E7%A7%BB%E4%BD%8Dcls/>累积版式移位（CLS）</a></li></ul></div></li><li><a class="docs-link rounded" href=/fed-regain/performance/web%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%A0%87%E5%87%86/>web性能指标标准</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E4%BA%A7%E5%93%81%E4%B8%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/>产品中的体验衡量指标</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD%E4%BD%93%E9%AA%8C%E7%BC%96%E7%A0%81%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96/>极致性能体验编码框架优化</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E7%9B%91%E6%8E%A7%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85/>监控要考虑的事情</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%BC%98%E5%8C%96/>网页加载渲染链路优化</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E8%B7%B3%E5%87%BA%E7%8E%87%E9%99%8D%E4%BD%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/>跳出率降低优化实践</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/>页面性能指标数据计算方法</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%9E%B6%E6%9E%84/>页面性能指标数据采集架构</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%81%E8%87%B4%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/>高性能极致用户体验开发实战</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-3c9c48e6a2da8db0cbd57c56e287665b aria-expanded=false>
打包构建</button><div class=collapse id=section-3c9c48e6a2da8db0cbd57c56e287665b><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/build/asm-js-%E5%92%8C-emscripten-%E4%BB%8B%E7%BB%8D/>asm.js 和 Emscripten 介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/babel%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/>babel涉及到的知识简单介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/dllplugin%E6%8F%90%E5%8D%87webpack%E7%BC%96%E8%AF%91/>DllPlugin提升webpack编译</a></li><li><a class="docs-link rounded" href=/fed-regain/build/es6%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-rollup%E9%80%9F%E8%A7%88/>ES6模块打包工具—Rollup速览</a></li><li><a class="docs-link rounded" href=/fed-regain/build/gruntgulp%E5%B7%A5%E5%85%B7/>Grunt，Gulp工具</a></li><li><a class="docs-link rounded" href=/fed-regain/build/gulp%E4%B8%AD%E7%9A%84sprite%E5%9B%BE%E5%92%8Cmixin/>Gulp中的sprite图和mixin</a></li><li><a class="docs-link rounded" href=/fed-regain/build/npm-shrinkwrap%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%E7%89%88%E6%9C%AC/>npm shrinkwrap命令分析版本</a></li><li><a class="docs-link rounded" href=/fed-regain/build/react%E5%9F%BA%E4%BA%8Ewebpack%E5%81%9Acode-splitting%E6%96%B9%E6%B3%95/>React基于webpack做code splitting方法</a></li><li><a class="docs-link rounded" href=/fed-regain/build/tree-shaking%E4%BB%8B%E7%BB%8D/>tree shaking介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/webpack%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%A5%9E%E5%99%A8/>Webpack模块加载神器</a></li><li><a class="docs-link rounded" href=/fed-regain/build/webpack%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/>webpack编译代码原理介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84llvm%E7%BC%96%E8%AF%91%E5%99%A8/>你不知道的LLVM编译器</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E4%BD%BF%E7%94%A8-webpack-chain-%E9%93%BE%E5%BC%8F%E7%94%9F%E6%88%90-webpack-%E9%85%8D%E7%BD%AE/>使用 Webpack-chain 链式生成 webpack 配置</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/>性能优化篇—Webpack构建速度优化</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%89%93%E5%8C%85%E4%B8%AD%E7%9A%84scope-hoisting%E5%8A%9F%E8%83%BD/>打包中的Scope Hoisting功能</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%89%93%E5%8C%85%E6%8A%80%E6%9C%AF%E8%A1%8C%E6%83%85/>打包技术行情</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%8F%90%E5%8D%87javascript%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE/>提升javascript代码编译速度的几点建议</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%E6%96%B0%E8%A1%8C%E6%83%852/>模块化打包新行情2</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E7%94%A8webpack4%E5%92%8C%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/>用webpack4和一些插件提升代码编译速度</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/>解决依赖组件版本冲突</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-a21c218df41f6d7fd032535fe20394e2 aria-expanded=false>
devops</button><div class=collapse id=section-a21c218df41f6d7fd032535fe20394e2><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/devops/chromedev%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95android%E5%92%8Cios/>chrome dev远程调试android 和ios</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/cp-rf%E8%BF%98%E6%98%AF%E6%8F%90%E9%97%AE-f%E5%A4%B1%E6%95%88/>cp -rf还是提问，-f失效</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ddos%E4%B9%8B%E8%BF%91%E6%BA%90%E6%B8%85%E6%B4%97/>DDOS之近源清洗</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/linux%E4%BD%BF%E7%94%A8tree%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/>linux使用tree命令查看目录结构</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/linux%E9%85%8D%E7%BD%AEnginx%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90https%E7%9A%84crt%E5%92%8Ckey%E8%AF%81%E4%B9%A6/>linux配置nginx自己生成https的crt和key证书</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/mysql%E7%9A%84join%E7%94%A8%E6%B3%95%E5%92%8C%E5%8D%95%E8%A1%A8%E8%87%AA%E8%BA%ABjoin/>mysql的join用法和单表自身join</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/>nginx反向代理配置</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/pm2%E5%90%AF%E5%8A%A8eggjs/>PM2启动eggjs</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/request-entity-too-large-nginx/>Request Entity Too Large Nginx</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/rsync%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E7%A4%BA%E4%BE%8B/>rsync基本用法和示例</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/serverless%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/>Serverless发展历程</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/sql_modeonly_full_group_by/>sql_mode=only_full_group_by</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ubuntu%E4%B8%ADsu%E4%B8%8Esudo%E7%9A%84%E5%8C%BA%E5%88%AB/>ubuntu中su与sudo的区别</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ubuntu%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/>ubuntu自定义开机启动脚本</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/vscode%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E6%AD%A5%E9%AA%A4/>Vscode插件发布步骤</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B9%8Bxss%E6%94%BB%E5%87%BB/>Web前端安全之XSS攻击</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/xcrun%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/>xcrun命令运行模拟器</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/yarn%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%BD%BF%E7%94%A8/>yarn快速上手使用</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E4%BD%BF%E7%94%A8-curl-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/>使用 CURL 上传文件</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F/>分布式调用链跟踪系统</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E5%9F%BA%E4%BA%8Echromedevtools%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/>基于Chrome devTools远程调试技术方案</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/git%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/>彻底搞懂 Git-Rebase</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/>需要知道的前端安全问题</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-36c4536996ca5615dcf9911f068786dc aria-expanded=false>
node</button><div class=collapse id=section-36c4536996ca5615dcf9911f068786dc><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/node/egg%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%9C%E7%94%A8/>Egg入门学习—理解中间件作用</a></li><li><a class="docs-link rounded" href=/fed-regain/node/egg%E7%90%86%E8%A7%A3service%E4%BD%BF%E7%94%A8/>egg理解service使用</a></li><li><a class="docs-link rounded" href=/fed-regain/node/node.js-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BA%A6%E5%AE%9A/>Node.js 代码规范约定</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs-express%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B/>NodeJS Express运行实例</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/>NodeJS 网络爬虫</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejsmongodb%E9%83%A8%E7%BD%B2%E5%88%B0linux/>NodeJS+mongoDB部署到Linux</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB/>nodejs入门阅读</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8Bchild_process/>nodejs子进程之child_process</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E7%9A%84buffer%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/>NodeJS的buffer使用总结</a></li><li><a class="docs-link rounded" href=/fed-regain/node/node%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/>node发送http请求以及参数处理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/npm%E7%89%88%E6%9C%AC%E5%8F%B7/>npm版本号</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enode%E5%A6%82%E4%BD%95%E5%81%9A%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/>关于node如何做接口限流</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enode%E7%BC%96%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>关于node编程异常处理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>关于NPM的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%9F%BA%E4%BA%8Enodejs%E5%88%9B%E5%BB%BAhttps%E6%9C%8D%E5%8A%A1/>基于Nodejs创建https服务</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E6%B5%85%E6%9E%90-node-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/>浅析 Node 进程与线程</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/>深入理解单线程实现高并发原理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E7%BD%91%E7%BB%9C%E5%BA%93libevent/>网络库libevent、libev、libuv对比</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-046a899ee7a6ec88d370211a518c9e80 aria-expanded=false>
算法</button><div class=collapse id=section-046a899ee7a6ec88d370211a518c9e80><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/algorithm/javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95/>JavaScript数组去重简单的方法</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/>n皇后问题</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%8D%A2%E7%AE%97/>人民币换算</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA-3-%E4%BD%8D%E6%95%B4%E6%95%B0/>反转一个整数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%A4%84%E7%90%86%E5%9B%9E%E6%96%87%E6%95%B0/>处理回文数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/>实现一个加减乘除的计算器</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/>常见算法思想</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/>序列化和反序列化二叉树</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/>找出数组中出现奇数次的元素</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/>找出数组和为零的子数组</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/>找出未排序整数数组的中位数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%88%B0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/>找到和为指定数值的两个数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9B%B8%E4%BA%B2%E6%95%B0%E5%AF%B9/>找指定范围相亲数对</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/>排序算法</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E4%B8%AD%E7%AC%AC-n-%E4%B8%AA%E6%95%B0/>查找斐波纳契数列中第 N 个数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/>查找水仙花数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/>查找第 k 大元素</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%A3%80%E9%AA%8C%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2/>检验是否为另一个字符串循环移动后的子串</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E7%A0%B4%E8%A7%A3%E7%BE%8E%E7%9C%89%E5%BE%AE%E4%BF%A1%E5%8F%B7/>破解美眉微信号707829217</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E7%BB%99%E5%AE%9A%E8%8C%83%E5%9B%B4%E6%95%B0%E5%AD%97%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%9A%84%E7%BB%93%E6%9E%9C/>给定范围数字按位与的结果</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/>计算后缀表达式（逆波兰表达式）</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95%E7%88%AC%E6%A5%BC%E6%A2%AF/>计算有多少种方法爬楼梯</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E7%BE%8E%E5%A5%B3%E4%B8%BB%E6%92%AD%E7%9B%B4%E6%92%AD%E9%97%B4%E5%AF%86%E7%A0%81/>计算美女主播直播间密码</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97-%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/>计算输入表达式+-*的所有可能计算结果</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-411887f8fe499f73c97eb21a4890b4b5 aria-expanded=true>
通向能力</button><div class="collapse show" id=section-411887f8fe499f73c97eb21a4890b4b5><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/think/%E4%B8%AD%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3/>中台的理解</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/>前端技能总结</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E5%9B%9E%E9%A1%BE%E5%89%8D%E7%AB%AF2019/>回顾前端2019</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E8%87%AA%E5%AD%A6%E9%9D%A2%E8%AF%95%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/>工程师自学面试找工作必备知识</a></li><li><a class="docs-link rounded active" href=/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/>校招社招必备核心面试问题与详细解答</a></li></ul></div></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar d-none d-lg-block"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-fc35fdc70d5fc69d269883a822c7a53e aria-expanded=false>
html</button><div class=collapse id=section-fc35fdc70d5fc69d269883a822c7a53e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/html/html%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/>HTML发展历史</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97%E7%BA%A6%E6%9D%9F/>HTML元素嵌套约束</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/>HTML解析过程</a></li><li><a class="docs-link rounded" href=/fed-regain/html/html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/>HTML渲染过程</a></li><li><a class="docs-link rounded" href=/fed-regain/html/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/>页面生命周期</a></li><li><a class="docs-link rounded" href=/fed-regain/html/content-security-policy/>Content-Security-Policy</a></li><li><a class="docs-link rounded" href=/fed-regain/html/noopener%E5%92%8Cnoreferrer/>noopener和noreferrer</a></li><li><a class="docs-link rounded" href=/fed-regain/html/preload%E5%92%8Cprefetch%E4%BC%98%E5%8C%96/>preload和prefetch优化</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-c7a628cba22e28eb17b5f5c6ae2a266a aria-expanded=false>
css</button><div class=collapse id=section-c7a628cba22e28eb17b5f5c6ae2a266a><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/css/css%E7%9A%84%E5%8F%91%E5%B1%95/>CSS的发展</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E4%BA%A4%E4%BA%92/>CSS交互</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E5%8F%98%E9%87%8F/>CSS变量</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E5%9F%BA%E7%BA%BF%E4%B8%8E%E8%A1%8C%E9%AB%98%E5%85%B3%E7%B3%BB/>css基线与行高关系</a></li><li><a class="docs-link rounded" href=/fed-regain/css/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97/>CSS选择器性能损耗</a></li><li><a class="docs-link rounded" href=/fed-regain/css/font-face%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/>font-face需要知道的一切</a></li><li><a class="docs-link rounded" href=/fed-regain/css/media-type-%E4%B8%8Emedia-query/>media type 与media query</a></li><li><a class="docs-link rounded" href=/fed-regain/css/minmax%E5%92%8Cclamp%E4%B8%89%E4%B8%AA%E9%80%BB%E8%BE%91/>minmax和clamp三个逻辑</a></li><li><a class="docs-link rounded" href=/fed-regain/css/containingblock/>什么是containing block？</a></li><li><a class="docs-link rounded" href=/fed-regain/css/content-visibility/>content-visibility</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E6%96%87%E6%9C%AC%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%E7%AD%89/>文本均匀分布两端对齐等</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%94%A8%E6%B3%95/>伪类与伪元素的用法</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E5%9B%BE%E7%89%87%E9%93%BA%E6%BB%A1%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%8F%98%E5%BD%A2/>图片铺满展示不变形</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E4%BD%BF%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%E6%97%81%E9%97%A8%E5%B7%A6%E9%81%93/>使元素不可见的旁门左道</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E7%90%86%E8%A7%A3css%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8A%A8%E7%94%BB%E8%B0%83%E8%AF%95/>理解CSS动画性能问题与动画调试</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E9%AB%98%E6%80%A7%E8%83%BDcss%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/>高性能CSS动画总结</a></li><li><a class="docs-link rounded" href=/fed-regain/css/%E5%8F%98%E6%80%81android%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/>变态android文字垂直居中</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-32981a13284db7a021131df49e6cd203 aria-expanded=false>
js</button><div class=collapse id=section-32981a13284db7a021131df49e6cd203><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-055823d5251a151ba2621eab0cb94843 aria-expanded=false>
js基础</button><div class=collapse id=section-055823d5251a151ba2621eab0cb94843><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/base/varletconst%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E5%9F%9F/>var、let、const及其作用域</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A4%9A%E8%A1%8C%E8%B6%85%E5%87%BA%E5%B0%BE%E9%83%A8%E5%B1%95%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%E6%94%B9%E8%BF%9B/>多行超出尾部展示省略号</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8/>二进制运算符使用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/typescript%E5%88%9D%E5%AD%A6%E4%BA%86%E8%A7%A3/>TypeScript初学了解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BD%BF%E7%94%A8fetch%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%99%E8%AF%AF/>工程师使用fetch常见的四种错误</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E6%9E%84%E5%BB%BAdom%E5%92%8Ccssom/>构建DOM和CSSOM</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E4%BA%8B%E4%BB%B6%E6%B5%81/>JavaScript事件流</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%85%B3%E4%BA%8Eajax%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AE%BE%E7%BD%AE/>关于ajax请求头设置</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3call/>函数调用的角度理解call</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%9F%BA%E4%BA%8Etypescript%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAnpm%E5%8C%85/>基于typescript开发一个npm包</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>简单的事件监听处理函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/>跨域和常用方法</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BA%86%E8%A7%A3%E4%B8%8Bpromise-a%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0promise/>了解下Promise A+规范，实现Promise</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%88%A4%E6%96%AD%E5%86%85%E5%AE%B9%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8/>判断内容区域是否滚动到底部</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%A7%A6%E6%91%B8%E5%8A%A8%E4%BD%9C/>如何高效响应用户触摸动作</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3function/>如何理解function</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8-service-workers%E6%8F%90%E5%8D%87%E4%BD%93%E9%AA%8C/>使用 Service Workers提升体验</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E5%92%8Cjsdoc%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E8%A7%84%E8%8C%83/>使用注释和JSDOC让代码更规范</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E4%BD%BF%E7%94%A8settimeout%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E5%92%8Csetinterval%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/>使用setTimeout循环调用和setInterval有什么区别</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B9%8Bpromise%E5%AF%B9%E8%B1%A1/>异步回调之Promise对象</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%8E%9F%E7%94%9Flazyloadcsp%E5%92%8Cdeno/>原生lazyload、csp和deno</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/typescript%E5%A4%A7%E6%B3%95/>typescript大法</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E8%A3%85/>原型，原型链，继承与组装</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE/>ES6常用语法回顾</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es2016%E8%A3%85%E9%A5%B0%E5%99%A8/>ES2016装饰器</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/globalwindowdocument-%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/>Global\window\document 简单说明</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/iframe%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>iframe的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/immutable%E8%AF%A6%E8%A7%A3/>IMMUTABLE 详解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>JavaScript跨域请求的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%85%E6%9E%90/>Javascript垃圾回收浅析</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>Javascript内存管理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/javascript%E5%AE%9E%E7%8E%B0jsonp%E5%92%8Cajax/>JavaScript实现JSONP和ajax</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/jquery%E7%AC%94%E8%AE%B0deferred/>jquery笔记deferred</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/webstorge%E4%BD%BF%E7%94%A8/>WebStorge使用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/js%E5%8E%9F%E7%94%9F%E7%BC%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0/>JS原生编解码函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/js%E4%B8%AD%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/>JS中浮点数精度问题</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/jsonp%E8%80%8C%E4%B8%8D%E6%98%AFajax/>jsonp而不是AJAX？</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/script%E6%A0%87%E7%AD%BE%E7%9A%84defer%E4%B8%8Easync/>script标签的defer与async</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/script%E6%A0%87%E7%AD%BE%E6%B7%BB%E5%8A%A0crossorigin/>script标签添加crossorigin</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/too-many-pausable-objects/>Too many Pausable Objects</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/touch%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E4%B8%8Eclick/>touch点击穿透与click与300ms延迟</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/es6-%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%8B%E9%9A%86/>ES6 … 拆箱与装箱实现深克隆</a></li><li><a class="docs-link rounded" href=/fed-regain/js/base/%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86/>浅克隆与深克隆</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b30ced48d20f44561d96d291478acbd8 aria-expanded=false>
js高级</button><div class=collapse id=section-b30ced48d20f44561d96d291478acbd8><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%8F%90%E5%8D%87%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/>执行上下文和提升与事件循环</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/object-defineproperty%E4%B8%8Eproxy/>Object.defineProperty与Proxy</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E8%AF%A6%E8%A7%A3object-createnull%E5%92%8Cnew%E5%8C%BA%E5%88%AB/>详解Object.create(null)和new区别</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%9F%BA%E4%BA%8Ees6%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC/>基于ES6标签模板实现事件绑定与数据监听</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%86if%E5%9D%97/>函数式编程处理IF块</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/>JS对象属性的快速删除</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E7%89%B9%E6%80%A7%E6%80%A7%E8%83%BD%E7%BC%BA%E9%99%B7%E5%8F%8Ajit%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/>JS特性性能缺陷及JIT的解决方案</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%AF%B9%E8%B1%A1%E5%9C%A8-v8-%E5%86%85%E7%9A%84%E8%A1%A8%E8%BE%BE/>JS对象在 V8 内的表达</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%A4%A7%E8%AF%9Djavascript-%E5%BC%95%E6%93%8E%E6%89%AB%E7%9B%B2%E7%AF%87/>大话JavaScript 引擎扫盲篇</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%9E%84%E5%BB%BAjavascript-%E6%B2%99%E7%AE%B1/>构建JavaScript 沙箱</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/>关于对象的访问优化</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E5%85%B3%E4%BA%8Ehit-test/>关于hit test</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/>控制反转和依赖注入</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/react-shadow/>react shadow</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/shadow-dom%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/>Shadow DOM简单了解</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/json-ld/>json-ld的用处</a></li><li><a class="docs-link rounded" href=/fed-regain/js/advance/js%E5%92%8Ccss%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E9%97%AE%E9%A2%98/>JS和CSS使用的一些小技巧和问题</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-43e6bf76b53ba4d9ffc765bf79022281 aria-expanded=false>
js框架</button><div class=collapse id=section-43e6bf76b53ba4d9ffc765bf79022281><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/js/framework/amd%E4%B8%8Ecmd%E8%A7%84%E8%8C%83-javascript%E6%A8%A1%E5%9D%97%E5%8C%96/>AMD与CMD规范-javascript模块化</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/bsrssgssr%E4%B9%8Bnext-js/>BSR、SSG、SSR之next.js</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/hooks%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/>hooks使用指南</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>JavaScript函数式编程</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/reactfiber%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/>react fiber怎么回事</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E5%AE%8C%E5%85%A8%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8C%97/>React Hooks完全上手指北</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E6%A8%A1%E6%8B%9F%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/>react hooks模拟各个生命周期函数</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hooks%E7%9A%84%E5%BA%94%E7%94%A8/>react hooks的应用</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-hook%E7%9A%84%E5%88%9D%E6%AD%A5%E7%A0%94%E7%A9%B6%E5%89%8D%E8%A8%80renderwithhooks%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B/>react hook的初步研究前言renderWithHooks的整个过程</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react-shadow/>react shadow</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/>react事件系统</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/react%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/>react阻止事件冒泡失败原因</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/svelte%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E6%80%A7%E5%8E%9F%E7%90%86/>Svelte框架的特性原理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/>vue3中的响应式原理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/>Vue3响应式原理整理</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue%E4%B8%8Eangular%E4%B8%8Ereact/>vue与angular与react</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/vue%E4%B8%AD8%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/>vue中8种组件通信方式</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/webcomponents%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/>web components入门与实践</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%9F%BA%E4%BA%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%86%99%E4%B8%80%E4%B8%AAeventemitter/>基于发布订阅模式写一个eventEmitter</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99vscode-extension%E6%8F%92%E4%BB%B6/>如何编写vscode extension插件</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%B0%86react%E5%BD%93%E5%81%9A%E5%89%8D%E7%AB%AFui%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E6%9D%A5%E7%9C%8B%E5%BE%85/>将React当做[前端](https://www.w3cdoc.com)UI运行时环境来看待</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/>工作流引擎比较规则引擎</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E4%B9%8Bvm%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/>数据监听之VM原理分析与实现</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E7%94%A8javascript%E8%87%AA%E5%B7%B1%E5%86%99virtual-dom/>用JavaScript自己写Virtual DOM</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/>自己写个前端路由</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/>路由原理和实现</a></li><li><a class="docs-link rounded" href=/fed-regain/js/framework/%E8%BD%ACreact-redux%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E6%9C%80%E6%98%93%E6%87%82%E7%9A%84%E8%AF%B4%E6%98%8E/>转:react-redux原理介绍，最易懂的说明</a></li></ul></div></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-82d4d1dc1b6fc48a08a1c8c2a4b805ec aria-expanded=false>
svg和canvas</button><div class=collapse id=section-82d4d1dc1b6fc48a08a1c8c2a4b805ec><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/canvas%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E4%B8%8E%E5%8A%A8%E7%94%BB/>canvas图片处理与动画</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/canvas%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%92%8C%E6%BB%A4%E9%95%9C%E7%89%B9%E6%95%88/>Canvas图像处理和滤镜特效</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E6%9B%BE%E7%BB%8F%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/>曾经基于canvas实现的飞机大战</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/fabric-js%E4%B9%8B%E5%BC%B7%E5%A4%A7%E7%9A%84svg%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/>fabric.js之強大的SVG处理工具类库</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/offscreencanvas-%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/>OffscreenCanvas – 概念说明及使用解析</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E6%96%B0%E6%80%9D%E8%B7%AF/>SVG压缩与字体图标新思路</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E5%B5%8C%E5%A5%97%E8%A7%86%E7%AA%97%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B/>SVG嵌套视窗综合实例</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%9A%84%E7%89%9Bb%E4%B9%8B%E5%A4%84%E4%BD%A0%E9%80%A0%E5%90%97/>SVG的牛B之处，你造吗</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%9A%84%E8%A7%86%E7%AA%97%E4%B8%8E%E5%AE%BD%E9%AB%98%E6%AF%94%E6%8E%A7%E5%88%B6/>SVG的视窗与宽高比控制</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/svg%E7%BC%A9%E6%94%BE%E7%A7%BB%E5%8A%A8%E5%80%BE%E6%96%9C%E5%92%8C%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/>SVG缩放，移动，倾斜和旋转变换</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB%E7%9A%84%E6%96%B9%E6%A1%88/>实现路径动画SMIL或offset-path和canvas</a></li><li><a class="docs-link rounded" href=/fed-regain/svgcanvas/%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-svg-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F%E5%8D%A0%E4%BD%8D%E7%AC%A6/>怎么使用 SVG 作为一个图像占位符</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-57f62e085cfdf20b39e12de8b1993112 aria-expanded=false>
dsl</button><div class=collapse id=section-57f62e085cfdf20b39e12de8b1993112><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/dsl/js%E6%A8%A1%E6%8B%9F%E7%BA%A2%E7%99%BD%E6%9C%BAjsnes%E4%BB%BB%E5%A4%A9%E5%A0%82%E6%B8%B8%E6%88%8F%E6%9C%BA/>js模拟红白机jsnes任天堂游戏机</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/sketch%E6%80%8E%E4%B9%88%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/>Sketch怎么开发插件</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E5%9F%BA%E4%BA%8Econfig-form%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/>基于config-form转向面向数据的编程</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E6%9E%84%E5%BB%BAc%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E8%B0%83%E7%A0%94/>构建C语言解释执行环境调研</a></li><li><a class="docs-link rounded" href=/fed-regain/dsl/%E6%B5%81%E7%A8%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/>流程驱动设计研发实战</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-db06c78d1e24cf708a14ce81c9b617ec aria-expanded=false>
测试</button><div class=collapse id=section-db06c78d1e24cf708a14ce81c9b617ec><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/test/%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/>可用性测试</a></li><li><a class="docs-link rounded" href=/fed-regain/test/%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7mocha-in-browser/>开发测试工具mocha-in-browser</a></li><li><a class="docs-link rounded" href=/fed-regain/test/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95+%E5%B7%A5%E5%85%B7/>测试方法+工具</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b7c0bfff1b6f1cc255716a1cb8b68011 aria-expanded=false>
调试</button><div class=collapse id=section-b7c0bfff1b6f1cc255716a1cb8b68011><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/debug/%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7weinre-2/>手机网页调试工具weinre</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-912302cb020149c37f9642fbc9e42891 aria-expanded=false>
浏览器</button><div class=collapse id=section-912302cb020149c37f9642fbc9e42891><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-9aa9f3eb840e2278563d9b10a2642144 aria-expanded=false>
HTTP协议</button><div class=collapse id=section-9aa9f3eb840e2278563d9b10a2642144><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/browser/http/http-2-%E4%B8%8E-web-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>HTTP/2 与 WEB 性能优化</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/https%E8%AE%BF%E9%97%AElocalhost%E7%9A%84http%E8%B5%84%E6%BA%90/>HTTPS访问localhost的http资源</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98vs%E5%BC%BA%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/>HTTP协商缓存VS强缓存原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8Ahttp2-0-1-1-1-0%E5%8C%BA%E5%88%AB/>HTTP协议以及HTTP2.0/1.1/1.0区别</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/websocket%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/>websocket建立连接</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E9%80%81options%E8%AF%B7%E6%B1%82/>什么时候会发送options请求</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E5%85%B3%E4%BA%8Echrome%E8%AF%B7%E6%B1%82stalled%E7%9A%84%E6%97%B6%E9%97%B4/>关于chrome请求stalled的时间</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/http-proxy/>基于正向代理解决方案实现的万能代理接口代理转发服务</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97-websocket%E5%AE%9E%E6%97%B6%E4%BA%92%E5%8A%A8%E5%B0%8F%E6%B8%B8%E6%88%8F/>移动[前端](https://www.w3cdoc.com)系列——websocket实时互动小游戏</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/http/%E8%AF%B4%E8%AF%B4http%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%A6%99%E7%94%A8/>说说http状态码和妙用</a></li></ul></div></li><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-e747eaca8d3884c2069788c67e22910e aria-expanded=false>
多端兼容性</button><div class=collapse id=section-e747eaca8d3884c2069788c67e22910e><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/h5%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>H5兼容性问题总结</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/ios%E4%BD%8E%E7%89%88%E6%9C%AC%E4%B8%ADjavascript%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/>ios低版本中JavaScript的兼容性问题</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/iphone6%E5%92%8C6s%E4%B8%ADwebview%E7%9A%84bug/>iphone6和6s中webview的bug</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/%E5%9F%BA%E4%BA%8Erem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/>基于rem方案实现自适应布局</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/compatible/%E6%89%8B%E6%9C%BA%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/>手机网页开发问题集锦</a></li></ul></div></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome-79%E9%BB%98%E8%AE%A4%E6%89%A7%E8%A1%8Csamesite-by-default%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%90%BA%E5%B8%A6cookie/>Chrome 79+默认执行SameSite-by-default，跨域请求默认不携带cookie</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E5%BC%80%E5%A7%8B%E9%9B%86%E6%88%90%E5%9B%BE%E5%BD%A2%E8%AF%86%E5%88%AB-apishape-detection-api/>Chrome开始集成图形识别 API（Shape Detection API）</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/>chrome插件开发</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8Eblinkv8/>Chrome浏览器引擎Blink&V8</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/provisional-headers-are-shown%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95/>Provisional headers are shown？怎么调试</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/webrtc%E7%9B%B8%E5%85%B3%E7%9A%84canvas%E4%B8%8Evideo/>WebRTC相关的canvas与video</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8web%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86/>浏览器JS引擎工作原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Enode%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/>浏览器与node环境的事件循环机制</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/>浏览器前进后退的缓存机制</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>浏览器工作原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%8E%E9%98%BB%E5%A1%9E%E5%8E%9F%E7%90%86/>浏览器渲染与阻塞原理</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BD%91%E9%A1%B5%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>浏览器渲染流水线解析与网页动画性能优化</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3%E4%B8%8Emicrotask%E4%B8%8Emacrotask/>浏览器线程理解与microtask与macrotask</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95/>浏览器默认超时时间测试</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E7%AE%80%E8%BF%B0chromium-cef-webkit-javascriptcore-v8-blink/>简述Chromium, CEF, Webkit, JavaScriptCore, V8, Blink</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E7%AE%A1%E7%90%86history%E4%B9%8Bpushstatereplacestate/>管理history之pushState、replaceState</a></li><li><a class="docs-link rounded" href=/fed-regain/browser/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A0%86%E6%A0%88/>虚拟机的堆和栈与数据结构堆栈</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-9214d980933ae261b589eaefbd7d256d aria-expanded=false>
微前端</button><div class=collapse id=section-9214d980933ae261b589eaefbd7d256d><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%9F%BA%E4%BA%8Econfig-component%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/>基于config-component转向面向数据的编程</a></li><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%9F%BA%E4%BA%8Ewebcomponents%E7%9A%84%E5%AE%9E%E7%8E%B0/>基于webcomponents的实现</a></li><li><a class="docs-link rounded" href=/fed-regain/microfe/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/>微前端架构的一些想法</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-b0f31b26d51a7233ea004c63cb714f7f aria-expanded=false>
性能体验</button><div class=collapse id=section-b0f31b26d51a7233ea004c63cb714f7f><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li class="my-1 ms-3"><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-f36dd17540804d4b2c456780caab0a2d aria-expanded=false>
性能体验埋点</button><div class=collapse id=section-f36dd17540804d4b2c456780caab0a2d><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E6%80%BB%E9%98%BB%E5%A1%9E%E6%97%B6%E9%97%B4tbt/>“总阻塞时间”（TBT）</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/elasticsearch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/>Elasticsearch入门学习</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/lcptbt%E4%B8%8Ecls%E6%8C%87%E6%A0%87/>LCP、TBT与CLS指标</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E4%BA%86%E8%A7%A3filebeat%E5%92%8C%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/>了解Filebeat和使用配置</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E6%9C%80%E5%A4%A7%E5%86%85%E5%AE%B9%E7%BB%98%E7%94%BBlcp/>最大内容绘画（LCP）</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/log/%E7%B4%AF%E7%A7%AF%E7%89%88%E5%BC%8F%E7%A7%BB%E4%BD%8Dcls/>累积版式移位（CLS）</a></li></ul></div></li><li><a class="docs-link rounded" href=/fed-regain/performance/web%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%A0%87%E5%87%86/>web性能指标标准</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E4%BA%A7%E5%93%81%E4%B8%AD%E7%9A%84%E4%BD%93%E9%AA%8C%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/>产品中的体验衡量指标</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD%E4%BD%93%E9%AA%8C%E7%BC%96%E7%A0%81%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96/>极致性能体验编码框架优化</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E7%9B%91%E6%8E%A7%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85/>监控要考虑的事情</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E4%BC%98%E5%8C%96/>网页加载渲染链路优化</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E8%B7%B3%E5%87%BA%E7%8E%87%E9%99%8D%E4%BD%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/>跳出率降低优化实践</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/>页面性能指标数据计算方法</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%9E%B6%E6%9E%84/>页面性能指标数据采集架构</a></li><li><a class="docs-link rounded" href=/fed-regain/performance/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%81%E8%87%B4%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/>高性能极致用户体验开发实战</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-3c9c48e6a2da8db0cbd57c56e287665b aria-expanded=false>
打包构建</button><div class=collapse id=section-3c9c48e6a2da8db0cbd57c56e287665b><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/build/asm-js-%E5%92%8C-emscripten-%E4%BB%8B%E7%BB%8D/>asm.js 和 Emscripten 介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/babel%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/>babel涉及到的知识简单介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/dllplugin%E6%8F%90%E5%8D%87webpack%E7%BC%96%E8%AF%91/>DllPlugin提升webpack编译</a></li><li><a class="docs-link rounded" href=/fed-regain/build/es6%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-rollup%E9%80%9F%E8%A7%88/>ES6模块打包工具—Rollup速览</a></li><li><a class="docs-link rounded" href=/fed-regain/build/gruntgulp%E5%B7%A5%E5%85%B7/>Grunt，Gulp工具</a></li><li><a class="docs-link rounded" href=/fed-regain/build/gulp%E4%B8%AD%E7%9A%84sprite%E5%9B%BE%E5%92%8Cmixin/>Gulp中的sprite图和mixin</a></li><li><a class="docs-link rounded" href=/fed-regain/build/npm-shrinkwrap%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%E7%89%88%E6%9C%AC/>npm shrinkwrap命令分析版本</a></li><li><a class="docs-link rounded" href=/fed-regain/build/react%E5%9F%BA%E4%BA%8Ewebpack%E5%81%9Acode-splitting%E6%96%B9%E6%B3%95/>React基于webpack做code splitting方法</a></li><li><a class="docs-link rounded" href=/fed-regain/build/tree-shaking%E4%BB%8B%E7%BB%8D/>tree shaking介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/webpack%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%A5%9E%E5%99%A8/>Webpack模块加载神器</a></li><li><a class="docs-link rounded" href=/fed-regain/build/webpack%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/>webpack编译代码原理介绍</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84llvm%E7%BC%96%E8%AF%91%E5%99%A8/>你不知道的LLVM编译器</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E4%BD%BF%E7%94%A8-webpack-chain-%E9%93%BE%E5%BC%8F%E7%94%9F%E6%88%90-webpack-%E9%85%8D%E7%BD%AE/>使用 Webpack-chain 链式生成 webpack 配置</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87-webpack%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/>性能优化篇—Webpack构建速度优化</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%89%93%E5%8C%85%E4%B8%AD%E7%9A%84scope-hoisting%E5%8A%9F%E8%83%BD/>打包中的Scope Hoisting功能</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%89%93%E5%8C%85%E6%8A%80%E6%9C%AF%E8%A1%8C%E6%83%85/>打包技术行情</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%8F%90%E5%8D%87javascript%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE/>提升javascript代码编译速度的几点建议</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%E6%96%B0%E8%A1%8C%E6%83%852/>模块化打包新行情2</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E7%94%A8webpack4%E5%92%8C%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/>用webpack4和一些插件提升代码编译速度</a></li><li><a class="docs-link rounded" href=/fed-regain/build/%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/>解决依赖组件版本冲突</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-a21c218df41f6d7fd032535fe20394e2 aria-expanded=false>
devops</button><div class=collapse id=section-a21c218df41f6d7fd032535fe20394e2><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/devops/chromedev%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95android%E5%92%8Cios/>chrome dev远程调试android 和ios</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/cp-rf%E8%BF%98%E6%98%AF%E6%8F%90%E9%97%AE-f%E5%A4%B1%E6%95%88/>cp -rf还是提问，-f失效</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ddos%E4%B9%8B%E8%BF%91%E6%BA%90%E6%B8%85%E6%B4%97/>DDOS之近源清洗</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/linux%E4%BD%BF%E7%94%A8tree%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/>linux使用tree命令查看目录结构</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/linux%E9%85%8D%E7%BD%AEnginx%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90https%E7%9A%84crt%E5%92%8Ckey%E8%AF%81%E4%B9%A6/>linux配置nginx自己生成https的crt和key证书</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/mysql%E7%9A%84join%E7%94%A8%E6%B3%95%E5%92%8C%E5%8D%95%E8%A1%A8%E8%87%AA%E8%BA%ABjoin/>mysql的join用法和单表自身join</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/>nginx反向代理配置</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/pm2%E5%90%AF%E5%8A%A8eggjs/>PM2启动eggjs</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/request-entity-too-large-nginx/>Request Entity Too Large Nginx</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/rsync%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E7%A4%BA%E4%BE%8B/>rsync基本用法和示例</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/serverless%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/>Serverless发展历程</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/sql_modeonly_full_group_by/>sql_mode=only_full_group_by</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ubuntu%E4%B8%ADsu%E4%B8%8Esudo%E7%9A%84%E5%8C%BA%E5%88%AB/>ubuntu中su与sudo的区别</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/ubuntu%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/>ubuntu自定义开机启动脚本</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/vscode%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83%E6%AD%A5%E9%AA%A4/>Vscode插件发布步骤</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/web%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B9%8Bxss%E6%94%BB%E5%87%BB/>Web前端安全之XSS攻击</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/xcrun%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/>xcrun命令运行模拟器</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/yarn%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%BD%BF%E7%94%A8/>yarn快速上手使用</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E4%BD%BF%E7%94%A8-curl-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/>使用 CURL 上传文件</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F/>分布式调用链跟踪系统</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E5%9F%BA%E4%BA%8Echromedevtools%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/>基于Chrome devTools远程调试技术方案</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/git%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/>彻底搞懂 Git-Rebase</a></li><li><a class="docs-link rounded" href=/fed-regain/devops/%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/>需要知道的前端安全问题</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-36c4536996ca5615dcf9911f068786dc aria-expanded=false>
node</button><div class=collapse id=section-36c4536996ca5615dcf9911f068786dc><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/node/egg%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%9C%E7%94%A8/>Egg入门学习—理解中间件作用</a></li><li><a class="docs-link rounded" href=/fed-regain/node/egg%E7%90%86%E8%A7%A3service%E4%BD%BF%E7%94%A8/>egg理解service使用</a></li><li><a class="docs-link rounded" href=/fed-regain/node/node.js-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BA%A6%E5%AE%9A/>Node.js 代码规范约定</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs-express%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B/>NodeJS Express运行实例</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/>NodeJS 网络爬虫</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejsmongodb%E9%83%A8%E7%BD%B2%E5%88%B0linux/>NodeJS+mongoDB部署到Linux</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB/>nodejs入门阅读</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8Bchild_process/>nodejs子进程之child_process</a></li><li><a class="docs-link rounded" href=/fed-regain/node/nodejs%E7%9A%84buffer%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/>NodeJS的buffer使用总结</a></li><li><a class="docs-link rounded" href=/fed-regain/node/node%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/>node发送http请求以及参数处理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/npm%E7%89%88%E6%9C%AC%E5%8F%B7/>npm版本号</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enode%E5%A6%82%E4%BD%95%E5%81%9A%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/>关于node如何做接口限流</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enode%E7%BC%96%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/>关于node编程异常处理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/>关于NPM的方方面面</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E5%9F%BA%E4%BA%8Enodejs%E5%88%9B%E5%BB%BAhttps%E6%9C%8D%E5%8A%A1/>基于Nodejs创建https服务</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E6%B5%85%E6%9E%90-node-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/>浅析 Node 进程与线程</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/>深入理解单线程实现高并发原理</a></li><li><a class="docs-link rounded" href=/fed-regain/node/%E7%BD%91%E7%BB%9C%E5%BA%93libevent/>网络库libevent、libev、libuv对比</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-046a899ee7a6ec88d370211a518c9e80 aria-expanded=false>
算法</button><div class=collapse id=section-046a899ee7a6ec88d370211a518c9e80><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/algorithm/javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95/>JavaScript数组去重简单的方法</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/>n皇后问题</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%8D%A2%E7%AE%97/>人民币换算</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA-3-%E4%BD%8D%E6%95%B4%E6%95%B0/>反转一个整数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%A4%84%E7%90%86%E5%9B%9E%E6%96%87%E6%95%B0/>处理回文数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/>实现一个加减乘除的计算器</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/>常见算法思想</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/>序列化和反序列化二叉树</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/>找出数组中出现奇数次的元素</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/>找出数组和为零的子数组</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%87%BA%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/>找出未排序整数数组的中位数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E5%88%B0%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/>找到和为指定数值的两个数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9B%B8%E4%BA%B2%E6%95%B0%E5%AF%B9/>找指定范围相亲数对</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/>排序算法</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E4%B8%AD%E7%AC%AC-n-%E4%B8%AA%E6%95%B0/>查找斐波纳契数列中第 N 个数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/>查找水仙花数</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/>查找第 k 大元素</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E6%A3%80%E9%AA%8C%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2/>检验是否为另一个字符串循环移动后的子串</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E7%A0%B4%E8%A7%A3%E7%BE%8E%E7%9C%89%E5%BE%AE%E4%BF%A1%E5%8F%B7/>破解美眉微信号707829217</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E7%BB%99%E5%AE%9A%E8%8C%83%E5%9B%B4%E6%95%B0%E5%AD%97%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%9A%84%E7%BB%93%E6%9E%9C/>给定范围数字按位与的结果</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/>计算后缀表达式（逆波兰表达式）</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%B3%95%E7%88%AC%E6%A5%BC%E6%A2%AF/>计算有多少种方法爬楼梯</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97%E7%BE%8E%E5%A5%B3%E4%B8%BB%E6%92%AD%E7%9B%B4%E6%92%AD%E9%97%B4%E5%AF%86%E7%A0%81/>计算美女主播直播间密码</a></li><li><a class="docs-link rounded" href=/fed-regain/algorithm/%E8%AE%A1%E7%AE%97-%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C/>计算输入表达式+-*的所有可能计算结果</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-411887f8fe499f73c97eb21a4890b4b5 aria-expanded=true>
通向能力</button><div class="collapse show" id=section-411887f8fe499f73c97eb21a4890b4b5><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/fed-regain/think/%E4%B8%AD%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3/>中台的理解</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/>前端技能总结</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E5%9B%9E%E9%A1%BE%E5%89%8D%E7%AB%AF2019/>回顾前端2019</a></li><li><a class="docs-link rounded" href=/fed-regain/think/%E8%87%AA%E5%AD%A6%E9%9D%A2%E8%AF%95%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/>工程师自学面试找工作必备知识</a></li><li><a class="docs-link rounded active" href=/fed-regain/think/%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/>校招社招必备核心面试问题与详细解答</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button>
<button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#doks-docs-nav aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>Book Menu</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#1关于性能优化说说js文件摆放顺序减少请求雪碧图等等原理-说下windowperformancetiming-api是干什么的>1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？</a></li><li><a href=#2请你描述下一个网页是如何渲染出来的dom树和css树是如何合并的浏览器httpswwww3cdoccom的运行机制是什么什么是否会造成渲染阻塞>2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，<a href=https://www.w3cdoc.com>浏览器</a>的运行机制是什么，什么是否会造成渲染阻塞？</a></li><li><a href=#3请简述下js引擎的工作原理js是怎样处理事件的eventloop宏任务源tasks和微任务源jobs分别有哪些js是如何构造抽象语法树ast的>3.请简述下js引擎的工作原理，js是怎样处理事件的eventloop，宏任务源tasks和微任务源jobs分别有哪些？js是如何构造抽象语法树（AST）的？</a></li><li><a href=#4你是否考虑全面你编写的整个函数或者整个功能的容错性与扩展性怎样构建一个组件是最合理最科学的对于错误的处理是否有统一的方式方法>4.你是否考虑全面你编写的整个函数，或者整个功能的容错性与扩展性？怎样构建一个组件是最合理最科学的，对于错误的处理是否有统一的方式方法？</a></li><li><a href=#5浏览器httpswwww3cdoccom缓存的基本策略什么时候该缓存什么时候不该缓存以及对于控制缓存的字段的相关设置是否清楚>5.<a href=https://www.w3cdoc.com>浏览器</a>缓存的基本策略，什么时候该缓存什么时候不该缓存，以及对于控制缓存的字段的相关设置是否清楚？</a></li><li><a href=#6你是否可以利用面向对象的思维去抽象你的功能你会构建一个classes6吗你对于前端httpswwww3cdoccom架构的理解>6.你是否可以利用面向对象的思维去抽象你的功能，你会构建一个class（ES6）吗？你对于<a href=https://www.w3cdoc.com>前端</a>架构的理解？</a></li><li><a href=#7你会用vue你会用react你读得懂这两个架构的源码吗你懂他俩的基本设计模式吗让你去构建一个类似的框架你如何下手>7.你会用VUE，你会用React，你读得懂这两个架构的源码吗？你懂他俩的基本设计模式吗？让你去构建一个类似的框架你如何下手？</a></li><li><a href=#8你了解的es6只是constletpromise吗你考虑过es6提出的真正趋势吗>8.你了解的ES6只是const、let、promise吗？你考虑过ES6提出的真正趋势吗？</a></li><li><a href=#9你会用less那么让你去写一个loader你可以吗>9.你会用less，那么让你去写一个loader你可以吗？</a></li><li><a href=#10webpack你也会用你了解其中原理吗你知道分析打包依赖的过程吗你知道tree-shaking是如何干掉无用重复的代码的吗>10.webpack你也会用，你了解其中原理吗？你知道分析打包依赖的过程吗？你知道tree-shaking是如何干掉无用重复的代码的吗？</a></li><li><a href=#11你真的熟练使用css吗那你知道position有几个属性吗>11.你真的熟练使用css吗，那你知道position有几个属性吗</a></li><li><a href=#115-前端httpswwww3cdoccom动画渲染机制了解吗硬件加速原理>11.5 <a href=https://www.w3cdoc.com>前端</a>动画渲染机制了解吗？硬件加速原理？</a></li><li><a href=#12你了解js的数据结构吗基本数据类型有哪些复杂数据类型有哪些在内存是如何表现的>12.你了解js的数据结构吗？基本数据类型有哪些？复杂数据类型有哪些？在内存是如何表现的？</a></li><li><a href=#13你可以用js去实现一个单向双向循环链表吗你可以实现查找插入删除操作吗>13.你可以用js去实现一个单向、双向、循环链表吗？你可以实现查找、插入、删除操作吗？</a></li><li><a href=#14你了解基本常见算法吗快速排序写一个要是限制空间利用你该如何写>14.你了解基本常见算法吗？快速排序写一个？要是限制空间利用你该如何写？</a></li><li><a href=#15你了解贪心算法动态规划分治算法回溯算法等常见的算法吗>15.你了解贪心算法、动态规划、分治算法、回溯算法等常见的算法吗？</a></li><li><a href=#16你是如何理解前端httpswwww3cdoccom架构的你了解持续集成吗>16.你是如何理解<a href=https://www.w3cdoc.com>前端</a>架构的？你了解持续集成吗？</a></li><li><a href=#17你了解基本的设计模式吗举例单例模式策略模式代理模式迭代模式发布订阅模式>17.你了解基本的设计模式吗？举例单例模式、策略模式、代理模式、迭代模式、发布订阅模式。。。？</a></li><li><a href=#18写一个事件监听函数呗实现onceonremoveemit功能>18.写一个事件监听函数呗？实现once、on、remove、emit功能</a></li><li><a href=#19nodejs的实现层是什么>19.node.js的实现层是什么？</a></li><li><a href=#20node的事件循环机制是怎样的node的child_process模块有几个api分别的作用是什么>20.node的事件循环机制是怎样的？node的child_process模块有几个api,分别的作用是什么？</a></li><li><a href=#22http10与11协议的区别node是如何实现http模块的>22.http1.0与1.1协议的区别？node是如何实现http模块的？</a></li><li><a href=#25nginx相关配置了解过吗>25.nginx相关配置了解过吗？</a></li><li><a href=#27小程序架构>27.小程序架构</a></li><li><a href=#28vue-v-model-语法糖vue-push式更新vue-computed和watch的区别>28. vue v-model 语法糖？vue push式更新？vue computed和watch的区别？</a></li><li><a href=#29-redux-dispatch一个action之后的更新过程>29. redux dispatch一个action之后的更新过程</a></li><li><a href=#30假设页面有多个模块每个模块都用到了getuser方法获取用户信息怎么设计通用的getuser避免发出多次请求>30.假设页面有多个模块，每个模块都用到了getUser方法获取用户信息，怎么设计通用的getUser避免发出多次请求。</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1关于性能优化说说js文件摆放顺序减少请求雪碧图等等原理-说下windowperformancetiming-api是干什么的>1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？</a></li><li><a href=#2请你描述下一个网页是如何渲染出来的dom树和css树是如何合并的浏览器httpswwww3cdoccom的运行机制是什么什么是否会造成渲染阻塞>2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，<a href=https://www.w3cdoc.com>浏览器</a>的运行机制是什么，什么是否会造成渲染阻塞？</a></li><li><a href=#3请简述下js引擎的工作原理js是怎样处理事件的eventloop宏任务源tasks和微任务源jobs分别有哪些js是如何构造抽象语法树ast的>3.请简述下js引擎的工作原理，js是怎样处理事件的eventloop，宏任务源tasks和微任务源jobs分别有哪些？js是如何构造抽象语法树（AST）的？</a></li><li><a href=#4你是否考虑全面你编写的整个函数或者整个功能的容错性与扩展性怎样构建一个组件是最合理最科学的对于错误的处理是否有统一的方式方法>4.你是否考虑全面你编写的整个函数，或者整个功能的容错性与扩展性？怎样构建一个组件是最合理最科学的，对于错误的处理是否有统一的方式方法？</a></li><li><a href=#5浏览器httpswwww3cdoccom缓存的基本策略什么时候该缓存什么时候不该缓存以及对于控制缓存的字段的相关设置是否清楚>5.<a href=https://www.w3cdoc.com>浏览器</a>缓存的基本策略，什么时候该缓存什么时候不该缓存，以及对于控制缓存的字段的相关设置是否清楚？</a></li><li><a href=#6你是否可以利用面向对象的思维去抽象你的功能你会构建一个classes6吗你对于前端httpswwww3cdoccom架构的理解>6.你是否可以利用面向对象的思维去抽象你的功能，你会构建一个class（ES6）吗？你对于<a href=https://www.w3cdoc.com>前端</a>架构的理解？</a></li><li><a href=#7你会用vue你会用react你读得懂这两个架构的源码吗你懂他俩的基本设计模式吗让你去构建一个类似的框架你如何下手>7.你会用VUE，你会用React，你读得懂这两个架构的源码吗？你懂他俩的基本设计模式吗？让你去构建一个类似的框架你如何下手？</a></li><li><a href=#8你了解的es6只是constletpromise吗你考虑过es6提出的真正趋势吗>8.你了解的ES6只是const、let、promise吗？你考虑过ES6提出的真正趋势吗？</a></li><li><a href=#9你会用less那么让你去写一个loader你可以吗>9.你会用less，那么让你去写一个loader你可以吗？</a></li><li><a href=#10webpack你也会用你了解其中原理吗你知道分析打包依赖的过程吗你知道tree-shaking是如何干掉无用重复的代码的吗>10.webpack你也会用，你了解其中原理吗？你知道分析打包依赖的过程吗？你知道tree-shaking是如何干掉无用重复的代码的吗？</a></li><li><a href=#11你真的熟练使用css吗那你知道position有几个属性吗>11.你真的熟练使用css吗，那你知道position有几个属性吗</a></li><li><a href=#115-前端httpswwww3cdoccom动画渲染机制了解吗硬件加速原理>11.5 <a href=https://www.w3cdoc.com>前端</a>动画渲染机制了解吗？硬件加速原理？</a></li><li><a href=#12你了解js的数据结构吗基本数据类型有哪些复杂数据类型有哪些在内存是如何表现的>12.你了解js的数据结构吗？基本数据类型有哪些？复杂数据类型有哪些？在内存是如何表现的？</a></li><li><a href=#13你可以用js去实现一个单向双向循环链表吗你可以实现查找插入删除操作吗>13.你可以用js去实现一个单向、双向、循环链表吗？你可以实现查找、插入、删除操作吗？</a></li><li><a href=#14你了解基本常见算法吗快速排序写一个要是限制空间利用你该如何写>14.你了解基本常见算法吗？快速排序写一个？要是限制空间利用你该如何写？</a></li><li><a href=#15你了解贪心算法动态规划分治算法回溯算法等常见的算法吗>15.你了解贪心算法、动态规划、分治算法、回溯算法等常见的算法吗？</a></li><li><a href=#16你是如何理解前端httpswwww3cdoccom架构的你了解持续集成吗>16.你是如何理解<a href=https://www.w3cdoc.com>前端</a>架构的？你了解持续集成吗？</a></li><li><a href=#17你了解基本的设计模式吗举例单例模式策略模式代理模式迭代模式发布订阅模式>17.你了解基本的设计模式吗？举例单例模式、策略模式、代理模式、迭代模式、发布订阅模式。。。？</a></li><li><a href=#18写一个事件监听函数呗实现onceonremoveemit功能>18.写一个事件监听函数呗？实现once、on、remove、emit功能</a></li><li><a href=#19nodejs的实现层是什么>19.node.js的实现层是什么？</a></li><li><a href=#20node的事件循环机制是怎样的node的child_process模块有几个api分别的作用是什么>20.node的事件循环机制是怎样的？node的child_process模块有几个api,分别的作用是什么？</a></li><li><a href=#22http10与11协议的区别node是如何实现http模块的>22.http1.0与1.1协议的区别？node是如何实现http模块的？</a></li><li><a href=#25nginx相关配置了解过吗>25.nginx相关配置了解过吗？</a></li><li><a href=#27小程序架构>27.小程序架构</a></li><li><a href=#28vue-v-model-语法糖vue-push式更新vue-computed和watch的区别>28. vue v-model 语法糖？vue push式更新？vue computed和watch的区别？</a></li><li><a href=#29-redux-dispatch一个action之后的更新过程>29. redux dispatch一个action之后的更新过程</a></li><li><a href=#30假设页面有多个模块每个模块都用到了getuser方法获取用户信息怎么设计通用的getuser避免发出多次请求>30.假设页面有多个模块，每个模块都用到了getUser方法获取用户信息，怎么设计通用的getUser避免发出多次请求。</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>校招社招必备核心面试问题与详细解答</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>On this page</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button>
<button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#doks-docs-nav aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>Book Menu</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><ul><li><a href=#1关于性能优化说说js文件摆放顺序减少请求雪碧图等等原理-说下windowperformancetiming-api是干什么的>1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？</a></li><li><a href=#2请你描述下一个网页是如何渲染出来的dom树和css树是如何合并的浏览器httpswwww3cdoccom的运行机制是什么什么是否会造成渲染阻塞>2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，<a href=https://www.w3cdoc.com>浏览器</a>的运行机制是什么，什么是否会造成渲染阻塞？</a></li><li><a href=#3请简述下js引擎的工作原理js是怎样处理事件的eventloop宏任务源tasks和微任务源jobs分别有哪些js是如何构造抽象语法树ast的>3.请简述下js引擎的工作原理，js是怎样处理事件的eventloop，宏任务源tasks和微任务源jobs分别有哪些？js是如何构造抽象语法树（AST）的？</a></li><li><a href=#4你是否考虑全面你编写的整个函数或者整个功能的容错性与扩展性怎样构建一个组件是最合理最科学的对于错误的处理是否有统一的方式方法>4.你是否考虑全面你编写的整个函数，或者整个功能的容错性与扩展性？怎样构建一个组件是最合理最科学的，对于错误的处理是否有统一的方式方法？</a></li><li><a href=#5浏览器httpswwww3cdoccom缓存的基本策略什么时候该缓存什么时候不该缓存以及对于控制缓存的字段的相关设置是否清楚>5.<a href=https://www.w3cdoc.com>浏览器</a>缓存的基本策略，什么时候该缓存什么时候不该缓存，以及对于控制缓存的字段的相关设置是否清楚？</a></li><li><a href=#6你是否可以利用面向对象的思维去抽象你的功能你会构建一个classes6吗你对于前端httpswwww3cdoccom架构的理解>6.你是否可以利用面向对象的思维去抽象你的功能，你会构建一个class（ES6）吗？你对于<a href=https://www.w3cdoc.com>前端</a>架构的理解？</a></li><li><a href=#7你会用vue你会用react你读得懂这两个架构的源码吗你懂他俩的基本设计模式吗让你去构建一个类似的框架你如何下手>7.你会用VUE，你会用React，你读得懂这两个架构的源码吗？你懂他俩的基本设计模式吗？让你去构建一个类似的框架你如何下手？</a></li><li><a href=#8你了解的es6只是constletpromise吗你考虑过es6提出的真正趋势吗>8.你了解的ES6只是const、let、promise吗？你考虑过ES6提出的真正趋势吗？</a></li><li><a href=#9你会用less那么让你去写一个loader你可以吗>9.你会用less，那么让你去写一个loader你可以吗？</a></li><li><a href=#10webpack你也会用你了解其中原理吗你知道分析打包依赖的过程吗你知道tree-shaking是如何干掉无用重复的代码的吗>10.webpack你也会用，你了解其中原理吗？你知道分析打包依赖的过程吗？你知道tree-shaking是如何干掉无用重复的代码的吗？</a></li><li><a href=#11你真的熟练使用css吗那你知道position有几个属性吗>11.你真的熟练使用css吗，那你知道position有几个属性吗</a></li><li><a href=#115-前端httpswwww3cdoccom动画渲染机制了解吗硬件加速原理>11.5 <a href=https://www.w3cdoc.com>前端</a>动画渲染机制了解吗？硬件加速原理？</a></li><li><a href=#12你了解js的数据结构吗基本数据类型有哪些复杂数据类型有哪些在内存是如何表现的>12.你了解js的数据结构吗？基本数据类型有哪些？复杂数据类型有哪些？在内存是如何表现的？</a></li><li><a href=#13你可以用js去实现一个单向双向循环链表吗你可以实现查找插入删除操作吗>13.你可以用js去实现一个单向、双向、循环链表吗？你可以实现查找、插入、删除操作吗？</a></li><li><a href=#14你了解基本常见算法吗快速排序写一个要是限制空间利用你该如何写>14.你了解基本常见算法吗？快速排序写一个？要是限制空间利用你该如何写？</a></li><li><a href=#15你了解贪心算法动态规划分治算法回溯算法等常见的算法吗>15.你了解贪心算法、动态规划、分治算法、回溯算法等常见的算法吗？</a></li><li><a href=#16你是如何理解前端httpswwww3cdoccom架构的你了解持续集成吗>16.你是如何理解<a href=https://www.w3cdoc.com>前端</a>架构的？你了解持续集成吗？</a></li><li><a href=#17你了解基本的设计模式吗举例单例模式策略模式代理模式迭代模式发布订阅模式>17.你了解基本的设计模式吗？举例单例模式、策略模式、代理模式、迭代模式、发布订阅模式。。。？</a></li><li><a href=#18写一个事件监听函数呗实现onceonremoveemit功能>18.写一个事件监听函数呗？实现once、on、remove、emit功能</a></li><li><a href=#19nodejs的实现层是什么>19.node.js的实现层是什么？</a></li><li><a href=#20node的事件循环机制是怎样的node的child_process模块有几个api分别的作用是什么>20.node的事件循环机制是怎样的？node的child_process模块有几个api,分别的作用是什么？</a></li><li><a href=#22http10与11协议的区别node是如何实现http模块的>22.http1.0与1.1协议的区别？node是如何实现http模块的？</a></li><li><a href=#25nginx相关配置了解过吗>25.nginx相关配置了解过吗？</a></li><li><a href=#27小程序架构>27.小程序架构</a></li><li><a href=#28vue-v-model-语法糖vue-push式更新vue-computed和watch的区别>28. vue v-model 语法糖？vue push式更新？vue computed和watch的区别？</a></li><li><a href=#29-redux-dispatch一个action之后的更新过程>29. redux dispatch一个action之后的更新过程</a></li><li><a href=#30假设页面有多个模块每个模块都用到了getuser方法获取用户信息怎么设计通用的getuser避免发出多次请求>30.假设页面有多个模块，每个模块都用到了getUser方法获取用户信息，怎么设计通用的getUser避免发出多次请求。</a></li></ul></li></ul></nav></div></div></div></div><div class="page-links d-none d-xl-block"><h3>On this page</h3><nav id=TableOfContents><ul><li><ul><li><a href=#1关于性能优化说说js文件摆放顺序减少请求雪碧图等等原理-说下windowperformancetiming-api是干什么的>1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？</a></li><li><a href=#2请你描述下一个网页是如何渲染出来的dom树和css树是如何合并的浏览器httpswwww3cdoccom的运行机制是什么什么是否会造成渲染阻塞>2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，<a href=https://www.w3cdoc.com>浏览器</a>的运行机制是什么，什么是否会造成渲染阻塞？</a></li><li><a href=#3请简述下js引擎的工作原理js是怎样处理事件的eventloop宏任务源tasks和微任务源jobs分别有哪些js是如何构造抽象语法树ast的>3.请简述下js引擎的工作原理，js是怎样处理事件的eventloop，宏任务源tasks和微任务源jobs分别有哪些？js是如何构造抽象语法树（AST）的？</a></li><li><a href=#4你是否考虑全面你编写的整个函数或者整个功能的容错性与扩展性怎样构建一个组件是最合理最科学的对于错误的处理是否有统一的方式方法>4.你是否考虑全面你编写的整个函数，或者整个功能的容错性与扩展性？怎样构建一个组件是最合理最科学的，对于错误的处理是否有统一的方式方法？</a></li><li><a href=#5浏览器httpswwww3cdoccom缓存的基本策略什么时候该缓存什么时候不该缓存以及对于控制缓存的字段的相关设置是否清楚>5.<a href=https://www.w3cdoc.com>浏览器</a>缓存的基本策略，什么时候该缓存什么时候不该缓存，以及对于控制缓存的字段的相关设置是否清楚？</a></li><li><a href=#6你是否可以利用面向对象的思维去抽象你的功能你会构建一个classes6吗你对于前端httpswwww3cdoccom架构的理解>6.你是否可以利用面向对象的思维去抽象你的功能，你会构建一个class（ES6）吗？你对于<a href=https://www.w3cdoc.com>前端</a>架构的理解？</a></li><li><a href=#7你会用vue你会用react你读得懂这两个架构的源码吗你懂他俩的基本设计模式吗让你去构建一个类似的框架你如何下手>7.你会用VUE，你会用React，你读得懂这两个架构的源码吗？你懂他俩的基本设计模式吗？让你去构建一个类似的框架你如何下手？</a></li><li><a href=#8你了解的es6只是constletpromise吗你考虑过es6提出的真正趋势吗>8.你了解的ES6只是const、let、promise吗？你考虑过ES6提出的真正趋势吗？</a></li><li><a href=#9你会用less那么让你去写一个loader你可以吗>9.你会用less，那么让你去写一个loader你可以吗？</a></li><li><a href=#10webpack你也会用你了解其中原理吗你知道分析打包依赖的过程吗你知道tree-shaking是如何干掉无用重复的代码的吗>10.webpack你也会用，你了解其中原理吗？你知道分析打包依赖的过程吗？你知道tree-shaking是如何干掉无用重复的代码的吗？</a></li><li><a href=#11你真的熟练使用css吗那你知道position有几个属性吗>11.你真的熟练使用css吗，那你知道position有几个属性吗</a></li><li><a href=#115-前端httpswwww3cdoccom动画渲染机制了解吗硬件加速原理>11.5 <a href=https://www.w3cdoc.com>前端</a>动画渲染机制了解吗？硬件加速原理？</a></li><li><a href=#12你了解js的数据结构吗基本数据类型有哪些复杂数据类型有哪些在内存是如何表现的>12.你了解js的数据结构吗？基本数据类型有哪些？复杂数据类型有哪些？在内存是如何表现的？</a></li><li><a href=#13你可以用js去实现一个单向双向循环链表吗你可以实现查找插入删除操作吗>13.你可以用js去实现一个单向、双向、循环链表吗？你可以实现查找、插入、删除操作吗？</a></li><li><a href=#14你了解基本常见算法吗快速排序写一个要是限制空间利用你该如何写>14.你了解基本常见算法吗？快速排序写一个？要是限制空间利用你该如何写？</a></li><li><a href=#15你了解贪心算法动态规划分治算法回溯算法等常见的算法吗>15.你了解贪心算法、动态规划、分治算法、回溯算法等常见的算法吗？</a></li><li><a href=#16你是如何理解前端httpswwww3cdoccom架构的你了解持续集成吗>16.你是如何理解<a href=https://www.w3cdoc.com>前端</a>架构的？你了解持续集成吗？</a></li><li><a href=#17你了解基本的设计模式吗举例单例模式策略模式代理模式迭代模式发布订阅模式>17.你了解基本的设计模式吗？举例单例模式、策略模式、代理模式、迭代模式、发布订阅模式。。。？</a></li><li><a href=#18写一个事件监听函数呗实现onceonremoveemit功能>18.写一个事件监听函数呗？实现once、on、remove、emit功能</a></li><li><a href=#19nodejs的实现层是什么>19.node.js的实现层是什么？</a></li><li><a href=#20node的事件循环机制是怎样的node的child_process模块有几个api分别的作用是什么>20.node的事件循环机制是怎样的？node的child_process模块有几个api,分别的作用是什么？</a></li><li><a href=#22http10与11协议的区别node是如何实现http模块的>22.http1.0与1.1协议的区别？node是如何实现http模块的？</a></li><li><a href=#25nginx相关配置了解过吗>25.nginx相关配置了解过吗？</a></li><li><a href=#27小程序架构>27.小程序架构</a></li><li><a href=#28vue-v-model-语法糖vue-push式更新vue-computed和watch的区别>28. vue v-model 语法糖？vue push式更新？vue computed和watch的区别？</a></li><li><a href=#29-redux-dispatch一个action之后的更新过程>29. redux dispatch一个action之后的更新过程</a></li><li><a href=#30假设页面有多个模块每个模块都用到了getuser方法获取用户信息怎么设计通用的getuser避免发出多次请求>30.假设页面有多个模块，每个模块都用到了getUser方法获取用户信息，怎么设计通用的getUser避免发出多次请求。</a></li></ul></li></ul></nav></div></nav><p>本文总结了<a href=https://www.w3cdoc.com>前端</a>老司机经常问题的一些问题并结合个人总结给出了比较详尽的答案。<strong>网易阿里腾讯校招社招必备知识点。</strong></p><p>原理讲解参考：[<a href=https://www.w3cdoc.com>前端</a>增长-重新定义大<a href=https://www.w3cdoc.com>前端</a>]<a href=https://www.f2e123.com/pwa/4651.html>1</a></p><p><a href=https://www.w3cdoc.com>前端</a>基础知识视频讲解<a href="https://study.163.com/course/courseMain.htm?courseId=1209400904" target=_blank rel="noopener noreferrer" data-ke-src="https://study.163.com/course/courseMain.htm?courseId=1209400904">：</a><a href="https://study.163.com/course/courseMain.htm?courseId=1209400904" target=_blank rel="noopener noreferrer" data-ke-src="https://study.163.com/course/courseMain.htm?courseId=1209400904">网易云课堂课程</a> <a href=https://segmentfault.com/ls/1650000019681091 target=_blank rel="noopener noreferrer" data-ke-src=https://segmentfault.com/ls/1650000019681091>思否segment课堂</a></p><h3 id=1关于性能优化说说js文件摆放顺序减少请求雪碧图等等原理-说下windowperformancetiming-api是干什么的>1.关于性能优化说说js文件摆放顺序、减少请求、雪碧图等等原理， 说下window.performance.timing api是干什么的？ <a href=#1%e5%85%b3%e4%ba%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e8%af%b4%e8%af%b4js%e6%96%87%e4%bb%b6%e6%91%86%e6%94%be%e9%a1%ba%e5%ba%8f%e5%87%8f%e5%b0%91%e8%af%b7%e6%b1%82%e9%9b%aa%e7%a2%a7%e5%9b%be%e7%ad%89%e7%ad%89%e5%8e%9f%e7%90%86-%e8%af%b4%e4%b8%8bwindowperformancetiming-api%e6%98%af%e5%b9%b2%e4%bb%80%e4%b9%88%e7%9a%84 class=anchor aria-hidden=true>#</a></h3><ul><li><a href=https://www.w3cdoc.com>浏览器</a>是按照文档流解析html，为了更快构建DOM树和渲染树将页面呈现到屏幕上，建议是降js放在文档dom树结尾，body标签闭合前。</li><li><a href=https://www.w3cdoc.com>浏览器</a>并发HTTP请求有限制（6个左右），加载页面html后开始解析，解析到外链资源比如js css和图片，就会发http请求获取对应资源。减少请求就是减少这些资源请求, 可以 css资源合并，js资源合并，图片资源合并同时做lazyload，区分首屏非首屏接口，按需请求数据。</li><li>雪碧图是一种图片资源的合并方法，将一些小图片合成一张图，通过background-position来定位到对应部分。</li><li>window.performance.timing 参考下[<a href=https://www.w3cdoc.com>前端</a>页面性能指标数据计算方法]<a href=https://www.f2e123.com/pwa/3301.html>2</a>, performance接口属于w3c标准hight resolution time中的一部分，通过navigation timeline api 、 performance timeline api，user timing api，resource timeline api 这四个接口做了增强实现。其中navigation timeline api中<a href=https://www.w3.org/TR/navigation-timing/#sec-navigation-timing-interface>PerformanceTiming</a> 接口数据放在 performance.timing这个对象上。主要记录了<a href=https://www.w3cdoc.com>浏览器</a>从跳转开始的各个时间点的时间，比如navigationStart是页面开始跳转时间，fetchStart是页面开始时间，domainLookupStart是DNS开始时间，domainLookupEnd是DNS结束时间， 查找到DNS后建立http链接，connectStart和connectEnd分别是链接开始和结束时间，然后是requestStart开始发起请求时间，responseStart开始响应时间，responseEnd响应结束时间。然后是苟安DOM树时间，分别是domLoading, domInteractive, domContentLoad和domComplete时间，分别对应document.<code>readyState</code>状态loading、interactive和complete。最后是页面onload，分别是loadEventStart和loadEventEnd时间节点。</li></ul><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-36-34.png></p><p>可以通过这个接口统计<a href=https://www.w3cdoc.com>前端</a>的页面性能数据。</p><ul><li>domainLookupStart - fetchStart = appCache时间，这段时间<a href=https://www.w3cdoc.com>浏览器</a>首先检查缓存</li><li>domainLookupEnd -domainLookupStart = DNS时间</li><li>connectEnd - connectStart = TCP时间</li><li>responseStart - requestStart = FTTB首字节时间，或者说是服务器响应等待时间</li><li>domContentLoad - navigationStart = 页面pageLoad时间</li><li>loadEventEnd - navigationStart = 页面onLoad时间</li></ul><h3 id=2请你描述下一个网页是如何渲染出来的dom树和css树是如何合并的浏览器httpswwww3cdoccom的运行机制是什么什么是否会造成渲染阻塞>2.请你描述下一个网页是如何渲染出来的，dom树和css树是如何合并的，<a href=https://www.w3cdoc.com>浏览器</a>的运行机制是什么，什么是否会造成渲染阻塞？ <a href=#2%e8%af%b7%e4%bd%a0%e6%8f%8f%e8%bf%b0%e4%b8%8b%e4%b8%80%e4%b8%aa%e7%bd%91%e9%a1%b5%e6%98%af%e5%a6%82%e4%bd%95%e6%b8%b2%e6%9f%93%e5%87%ba%e6%9d%a5%e7%9a%84dom%e6%a0%91%e5%92%8ccss%e6%a0%91%e6%98%af%e5%a6%82%e4%bd%95%e5%90%88%e5%b9%b6%e7%9a%84%e6%b5%8f%e8%a7%88%e5%99%a8httpswwww3cdoccom%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e6%98%af%e4%bb%80%e4%b9%88%e4%bb%80%e4%b9%88%e6%98%af%e5%90%a6%e4%bc%9a%e9%80%a0%e6%88%90%e6%b8%b2%e6%9f%93%e9%98%bb%e5%a1%9e class=anchor aria-hidden=true>#</a></h3><p>参考下：[<a href=https://www.w3cdoc.com>浏览器</a>工作原理]<a href=https://www.f2e123.com/javascriptnodejs/665.html>4</a>  [<a href=https://www.w3cdoc.com>浏览器</a>渲染与阻塞原理]<a href=https://www.f2e123.com/pwa/4441.html>5</a></p><p>第一部分通过performance.time这个api<a href=https://www.w3cdoc.com>我们</a>可以了解<a href=https://www.w3cdoc.com>浏览器</a>加载网页的流程，<a href=https://www.w3cdoc.com>浏览器</a>边加载html边构建DOM树，当然会有容错和修正机制。<a href=https://www.w3cdoc.com>浏览器</a>解析到行内css和内联css会立马加入到构建渲染树，解析到外链css就开始加载，加载完之后也会合并到渲染树的构建中，最后将渲染树和DOM做节点链路匹配，也叫layout阶段，计算每个DOM元素最终在屏幕上显示的大小和位置。 遍历顺序为从左至右，从上到下，绘制在屏幕上，layout过程中可能会触发页面回流和重绘，比如某个外链css加载完解析之后合并构建到渲染树中，其中某个css改变了DOM树种某个元素的定位（改成绝对定位）或者改变了长宽边距等位置信息，会触发重新layout，所以会回流reflow。重绘是比如css改变了之前的背景图片颜色，<a href=https://www.w3cdoc.com>浏览器</a>会重新绘制。</p><p>会有渲染阻塞，<a href=https://www.w3cdoc.com>浏览器</a>刷新的频率大概是60次/秒， 也就是说刷新一次大概时间为16ms，如果<a href=https://www.w3cdoc.com>浏览器</a>对每一帧的渲染工作超过了这个时间， 页面的渲染就会出现卡顿的现象。<a href=https://www.w3cdoc.com>浏览器</a>内核中有3个最主要的线程：JS线程，UI渲染线程，事件处理线程。此外还有http网络线程，定时器任务线程，文件系统处理线程等等。</p><ul><li>JS线程负责JS代码解析编译执行，称为主线程。常说‘<a href=https://www.w3cdoc.com>浏览器</a>是单线程’指的是JS主线程只能有一个，主线程执行同步任务，会阻塞UI渲染线程。JS线程核心是js引擎 （IE9+: Chakra firefox:monkey chrome:v8）。webworker可以创建多个js线程，但是受主线程控制，主要用于cpu密集型计算。</li><li>UI渲染线程当然是负责构建渲染树，执行页面元素渲染。核心是渲染引擎（firefox：gecko、chrome/safari：webkit），由于JS可以操作DOM元素处理样式等，JS主线程是执行同步任务的，所以设计上JS引擎线程和GUI渲染线程是互斥的。 也就是说JS引擎处于运行状态时，GUI渲染线程将处于冻结状态。</li><li>事件处理线程，由于<a href=https://www.w3cdoc.com>浏览器</a>是事件驱动的，事件处理线程用来控制事件回调处理，<a href=https://www.w3cdoc.com>浏览器</a>触发某个事件后会把事件回调函数放到任务队列中，可以看下下面会提到。</li><li>其他线程统称工作线程，如处理 ajax 的线程，dom事件线程、定时器线程、读写文件的线程等，工作线程的任务完成之后， 会推入到一个任务队列（task queue）</li></ul><p>总结一下，渲染阻塞有两个方面：</p><ul><li>js主线程执行时间长会导致渲染线程阻塞，影响渲染。<a href=https://www.w3cdoc.com>我们</a>也称为longtask</li><li>渲染线程自身阻塞，渲染时间达不到帧率60，会看起来卡顿，比如回流或者重绘等，或者css效率太低，动画处理不合适，导致渲染耗时</li></ul><h3 id=3请简述下js引擎的工作原理js是怎样处理事件的eventloop宏任务源tasks和微任务源jobs分别有哪些js是如何构造抽象语法树ast的>3.请简述下js引擎的工作原理，js是怎样处理事件的eventloop，宏任务源tasks和微任务源jobs分别有哪些？js是如何构造抽象语法树（AST）的？ <a href=#3%e8%af%b7%e7%ae%80%e8%bf%b0%e4%b8%8bjs%e5%bc%95%e6%93%8e%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86js%e6%98%af%e6%80%8e%e6%a0%b7%e5%a4%84%e7%90%86%e4%ba%8b%e4%bb%b6%e7%9a%84eventloop%e5%ae%8f%e4%bb%bb%e5%8a%a1%e6%ba%90tasks%e5%92%8c%e5%be%ae%e4%bb%bb%e5%8a%a1%e6%ba%90jobs%e5%88%86%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9bjs%e6%98%af%e5%a6%82%e4%bd%95%e6%9e%84%e9%80%a0%e6%8a%bd%e8%b1%a1%e8%af%ad%e6%b3%95%e6%a0%91ast%e7%9a%84 class=anchor aria-hidden=true>#</a></h3><p>js引擎只执行同步任务, 异步任务会有工作线程来执行，当需要进行异步操作（定时器、ajax请求、dom事件注册等）， 主线程会发一个异步任务的请求， 相应的工作线程接受请求； 当工作线程完成工作之后， 通知主线程；主线程接收到通知之后， 会执行一定的操作（回调函数）。主线程和工作线程之间的通知机制叫做事件循环。</p><ul><li>调用栈 （call stack）: 主线程执行时生成的调用栈</li><li>任务队列 （task queue）: 工作线程完成任务后会把消息推到一个任务队列， 消息就是注册时的回调函数</li></ul><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-36-46.png></p><p>当调用栈为空时， 主线程会从任务队列里取一条消息并放入当前的调用栈当中执行， 主线程会一直重复这个动作直到消息队列为空。 这个过程就叫做事件循环 （event-loop）。</p><p>关于宏任务和微任务，参考 <a href=https://www.f2e123.com/question/%e4%ba%8b%e4%bb%b6%e6%b5%81%e3%80%81%e4%ba%8b%e4%bb%b6%e6%a8%a1%e5%9e%8b%e3%80%81%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%a6%82%e5%bf%b5%e7%90%86%e8%a7%a3%ef%bc%9f>事件流、事件模型、事件循环概念理解？</a> [<a href=https://www.w3cdoc.com>浏览器</a>线程理解与microtask与macrotask]<a href=https://www.f2e123.com/aistack/3331.html>7</a></p><p>ES6新引入了Promise标准，同时<a href=https://www.w3cdoc.com>浏览器</a>实现上多了一个microtask微任务概念。在ECMAScript中，microtask称为<code>jobs</code>，macrotask可称为<code>task</code>。</p><ul><li>macrotask宏任务tasks，也就是上面说到的任务队列的任务。执行栈上的每个任务都属于宏任务，主线程执行完执行栈的任务，从任务队列取新的任务。宏任务执行时不会中断，会一次性执行完，为了及时渲染数据，主线程执行完一个宏任务之后，会执行一次渲染。</li></ul><p>task-》渲染 -》宏任务 -》渲染  …..</p><ul><li>microtask微任务jobs，可以看成是插队需要及时处理的任务，会在当前主线程task任务执行后，渲染线程渲染之前，执行完当前积累所有的微任务。</li></ul><p>task-》jobs -》渲染 -》宏任务 -》jobs -》渲染  …..</p><p>AST 参考：<a href=https://www.f2e123.com/javascriptnodejs/1867.html>程序语言进阶之DSL与AST实战解析</a></p><p>将抽象语法树之前要先了解下NLP中文法的概率。任何一种语言，具体说就是DSL，都有自己的一套文法，用来表示这套语言的逻辑规范。不同的文法写出来的语法表达式也不一样。<a href=https://www.w3cdoc.com>我们</a>根据语法表达式来解析语言，就可以形成一个AST抽象语法树。然后可以作进一步处理。我常用的是PEG解析表达式语法。可以很轻松的写出语法的每一条产生式规则，来构造生成AST。所谓AST可以理解成按照一定语法结构组成的词汇流，每个词汇有特定的语法含义，比如说这是一个声明，这个一个操作符等等。</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-36-57.png></p><p>上面这个图是苹果最早做的KHTML渲染引擎中的KJS（javascript引擎），他是基于AST来实现的JavaScript语言解析的，先通过词法分析得到JSTokens流，然后经过语法分析得到抽象语法树，然后经过字节码生成器，转换成字节码。字节码经过JavaScript虚拟机JIT编译成机器码，然后执行。这是最初的设计架构，后来苹果公司基于此重构出了webkit渲染引擎，google基于webkit单独维护，称为blink渲染引擎，chrome的JS引擎改造为V8引擎。参考：<a href=https://www.f2e123.com/javascriptnodejs/4481.html>简述Chromium, CEF, Webkit, JavaScriptCore, V8, Blink</a></p><p>举个例子常用的babel插件的原理就是基于babylon词法语法分析器生成抽象语法树，将代码文本转换成按照特定语法组合的token流集合，然后经过babtlon-traverse这个组件来负责处理遍历语法树，访问每个token节点，通过对token的处理，可以生成<a href=https://www.w3cdoc.com>我们</a>需要的AST语法树，然后再通过babylon-generator这个组件来做代码生成，根据AST生成代码。比如可以将 箭头函数 转换成 function函数。</p><p><a href=https://www.w3cdoc.com>浏览器</a>中，通过开发者调试工具分析就能看到，下载完js脚本后，首先<a href=https://www.w3cdoc.com>浏览器</a>要先解析代码=》初始化上下文环境=》执行代码，整个是evaluate script的过程，解析代码的过程也是编译js的过程所以看最前面第一步就是compile script，将js代码编译成字节码（这一块涉及到<a href=https://www.w3cdoc.com>浏览器</a>js引擎的优化，v8引擎是编译成字节码，后面经过JIT解析执行（这个参考 <a href=https://www.f2e123.com/pwa/4401.html>你不知道的LLVM编译器</a> 可以提升效率做动态优化）, 这个类似于java、C#这些需要将源代码编译成中间语言，然后在虚拟机执行，javascript编译成字节码后面也是在虚拟机执行），然后就开始执行脚本。</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-37-07.png></p><h3 id=4你是否考虑全面你编写的整个函数或者整个功能的容错性与扩展性怎样构建一个组件是最合理最科学的对于错误的处理是否有统一的方式方法>4.你是否考虑全面你编写的整个函数，或者整个功能的容错性与扩展性？怎样构建一个组件是最合理最科学的，对于错误的处理是否有统一的方式方法？ <a href=#4%e4%bd%a0%e6%98%af%e5%90%a6%e8%80%83%e8%99%91%e5%85%a8%e9%9d%a2%e4%bd%a0%e7%bc%96%e5%86%99%e7%9a%84%e6%95%b4%e4%b8%aa%e5%87%bd%e6%95%b0%e6%88%96%e8%80%85%e6%95%b4%e4%b8%aa%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%b9%e9%94%99%e6%80%a7%e4%b8%8e%e6%89%a9%e5%b1%95%e6%80%a7%e6%80%8e%e6%a0%b7%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e7%bb%84%e4%bb%b6%e6%98%af%e6%9c%80%e5%90%88%e7%90%86%e6%9c%80%e7%a7%91%e5%ad%a6%e7%9a%84%e5%af%b9%e4%ba%8e%e9%94%99%e8%af%af%e7%9a%84%e5%a4%84%e7%90%86%e6%98%af%e5%90%a6%e6%9c%89%e7%bb%9f%e4%b8%80%e7%9a%84%e6%96%b9%e5%bc%8f%e6%96%b9%e6%b3%95 class=anchor aria-hidden=true>#</a></h3><p>扩展性主要是从功能上考虑，容错性是从数据上考虑。</p><ul><li>设计开发组件的时候首先要设计好数据模型，当然可以和后端共同约定一个标准，后面只要是这部分都用这个标准字段。后面可以对标准字段做扩展，开发时候要做容错和数据响应式开发。</li><li>功能这部分其实可以从基础功能和扩展功能来看，基础功能可以在原有组件上做根据数据来展示。扩展功能可以通过组件结合的形式来处理。</li></ul><p>我主要考虑的是组件复用，可以将一类组件归类，比如商品卡片，基本都是头图加标题行动点，价格，按钮。这就是最基础的一个组件。扩展性可以通过数据来做响应式的展示，比如新增一个描述，数据模型新增描述字段，有描述字段卡片上就展示描述，没有就不展示。像点击按钮的加购功能可以单独做成功能组件，统一处理，而不放在卡片上。因为这种加购往往附带的是商业逻辑，有很多业务逻辑要处理，独立出来反而更利于维护和拓展。</p><p>错误处理<a href=https://www.w3cdoc.com>我们</a>这边是基于组件的方式来处理，开发一个错误处理的功能组件，提供thenable的能力，区分不同的错误类型，提供统一埋点做监控和记录。</p><h3 id=5浏览器httpswwww3cdoccom缓存的基本策略什么时候该缓存什么时候不该缓存以及对于控制缓存的字段的相关设置是否清楚>5.<a href=https://www.w3cdoc.com>浏览器</a>缓存的基本策略，什么时候该缓存什么时候不该缓存，以及对于控制缓存的字段的相关设置是否清楚？ <a href=#5%e6%b5%8f%e8%a7%88%e5%99%a8httpswwww3cdoccom%e7%bc%93%e5%ad%98%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ad%96%e7%95%a5%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e8%af%a5%e7%bc%93%e5%ad%98%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%b8%8d%e8%af%a5%e7%bc%93%e5%ad%98%e4%bb%a5%e5%8f%8a%e5%af%b9%e4%ba%8e%e6%8e%a7%e5%88%b6%e7%bc%93%e5%ad%98%e7%9a%84%e5%ad%97%e6%ae%b5%e7%9a%84%e7%9b%b8%e5%85%b3%e8%ae%be%e7%bd%ae%e6%98%af%e5%90%a6%e6%b8%85%e6%a5%9a class=anchor aria-hidden=true>#</a></h3><p>参考下：<a href=https://www.f2e123.com/pwa/3779.html>HTTP协商缓存VS强缓存原理</a></p><p>前面介绍navigation api时候介绍了<a href=https://www.w3cdoc.com>浏览器</a>加载页面的各个关键时间节点。和缓存相关的主要有两部分</p><ul><li>appcache，这部分是离线缓存，在fetchStart和domainLookupStart之间，这部分参考<a href=https://html.spec.whatwg.org/#offline>whatwg</a>标准已经弃用，建议用serviceworker。这里也不做介绍。</li><li>HTTP缓存这部分是在requestStart开始，发起资源http请求开始，这部分涉及到强缓存和协商缓存。<a href=https://www.w3cdoc.com>浏览器</a>对于请求过得资源会缓存下来请求的响应数据，后面请求时会先从缓存查找匹配的请求的响应头，如果命中强缓存（判断cache-control和expires信息）那么直接从缓存获取响应数据，不会再发送http请求。如果没有命中<a href=https://www.w3cdoc.com>浏览器</a>会发送请求到服务器，同时会携带第一次请求的响应头的缓存相关header字段（last-modified/if-modified-since, Etag/if-none-match）, 服务端根据这些请求头判断是否走缓存，如果走缓存，服务端会返回新的响应头，但不返回数据，<a href=https://www.w3cdoc.com>浏览器</a>会更新响应头，从缓存拿数据。如果不走缓存，服务端就会返回新的响应头和数据，然后<a href=https://www.w3cdoc.com>浏览器</a>更新缓存的数据。</li></ul><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-37-18.png></p><p>-》强缓存，判断依据是expires（http 1.0协议规定）和cache-control（http 1.1协议规定）字段，expires是绝对时间，cache-control有可选值no-cache（不使用本地缓存，走协商缓存），no-store（禁止<a href=https://www.w3cdoc.com>浏览器</a>缓存数据，每次都是重新获取数据），public（可以被客户端和中间商CDN做缓存），private（只能客户端缓存，CDN不能缓存）</p><p>-》协商缓存，用到的响应头字段是last-modified/if-modified-since, Etag/if-none-match，这是两对哈，每队/前面一个是服务端返回的response header中的字段，/后面是请求头request携带的头部字段，第一次请求资源<a href=https://www.w3cdoc.com>浏览器</a>会返回last-modified（最后修改时间），后面再次请求请求头会带上if-modified-since，当然这个值和上次<a href=https://www.w3cdoc.com>浏览器</a>返回的last-modified是一样的，然后<a href=https://www.w3cdoc.com>浏览器</a>判断如果文件没有变化，那么返回304 Not Modified http code，响应请求头不会携带last-modified字段，<a href=https://www.w3cdoc.com>浏览器</a>从缓存取数据，也不用更新last-modified字段，如果有修改，那么响应头返回新的last-modified字段数据，返回响应内容。Etag/if-none-match这一对是同样的逻辑，不同之处是用etag标识来判断文件是否修改，而不是用时间，因为服务器时间可能会变的，还会收到时区的影响。还有一点是每次请求都会返回etag字段，即使没有变化。</p><h3 id=6你是否可以利用面向对象的思维去抽象你的功能你会构建一个classes6吗你对于前端httpswwww3cdoccom架构的理解>6.你是否可以利用面向对象的思维去抽象你的功能，你会构建一个class（ES6）吗？你对于<a href=https://www.w3cdoc.com>前端</a>架构的理解？ <a href=#6%e4%bd%a0%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e5%88%a9%e7%94%a8%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e6%80%9d%e7%bb%b4%e5%8e%bb%e6%8a%bd%e8%b1%a1%e4%bd%a0%e7%9a%84%e5%8a%9f%e8%83%bd%e4%bd%a0%e4%bc%9a%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aaclasses6%e5%90%97%e4%bd%a0%e5%af%b9%e4%ba%8e%e5%89%8d%e7%ab%afhttpswwww3cdoccom%e6%9e%b6%e6%9e%84%e7%9a%84%e7%90%86%e8%a7%a3 class=anchor aria-hidden=true>#</a></h3><p>我目前开发分情况用不同的技术框架。</p><ul><li>如果单纯开发导购页面，比如一个商品列表页面，这种为了加载性能和操作体验，我是不考虑用框架的，也不用class，单纯用自己开发的原生ES框架自己控制页面模块生命周期，基于函数式编程写stateless组件。尽量减少复杂度，简单化。</li><li>如果是开发功能性组件，我是会用面型对象的模式来做开发。面向对象的核心是封装、继承、多态。封装就是将具体化为抽象，抽象成class，封装抽象出来的属性和方法。继承是因为抽象可以有层级，比如对异常处理，参数异常可以抽象成一类，状态异常可以抽象成一类，参数异常和状态异常有共通的地方，比如结构上都会返回异常的名称和描述，这就可以抽象一层公共父类，然后这两个异常继承自公共父类，这就是集成。多态也是随着继承而来的，比如参数异常和状态异常都继承了name这个属性，都可以实现对应的get方法，但是他们的实现结果可定是不一样的，根据自身类的抽象来实现，调用的时候调用同样的方法也就有不同的表现。比如参数异常和状态异常都继承了toString的方法，在调用各自的实例的toString方法时，输出的数据是不一样的。另外设计的2大原则是：单一职责原则和开放封闭原则。单一职责只是抽象的类尽量保持功能专一，开闭原则指设计的时候要考虑好扩展，对修改关闭，对扩展开放。</li></ul><pre><code>export class RuntimeException {

    constructor(message) {
        this._message = message;
    }

    get name() {
        return 'RuntimeException';
    }

    get message() {
        return this._message;
    }

    toString() {
        return this.name + ': ' + this.message;
    }

}

export class IllegalStateException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'IllegalStateException';
    }

}

export class InvalidArgumentException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'InvalidArgumentException';
    }

}

export class NotImplementedException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'NotImplementedException';
    }

}
</code></pre><p>对于<a href=https://www.w3cdoc.com>前端</a>领域来说，目前<a href=https://www.w3cdoc.com>前端</a>框架做掉了很多事情，搭建好项目框架之后，开发的就行就是填功能。所编写的模块和组件的模式也比较固定，可以根据具体情况来实现。</p><h3 id=7你会用vue你会用react你读得懂这两个架构的源码吗你懂他俩的基本设计模式吗让你去构建一个类似的框架你如何下手>7.你会用VUE，你会用React，你读得懂这两个架构的源码吗？你懂他俩的基本设计模式吗？让你去构建一个类似的框架你如何下手？ <a href=#7%e4%bd%a0%e4%bc%9a%e7%94%a8vue%e4%bd%a0%e4%bc%9a%e7%94%a8react%e4%bd%a0%e8%af%bb%e5%be%97%e6%87%82%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%9e%b6%e6%9e%84%e7%9a%84%e6%ba%90%e7%a0%81%e5%90%97%e4%bd%a0%e6%87%82%e4%bb%96%e4%bf%a9%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%90%97%e8%ae%a9%e4%bd%a0%e5%8e%bb%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e7%b1%bb%e4%bc%bc%e7%9a%84%e6%a1%86%e6%9e%b6%e4%bd%a0%e5%a6%82%e4%bd%95%e4%b8%8b%e6%89%8b class=anchor aria-hidden=true>#</a></h3><p>angular</p><p>特点： 数据双向绑定-》数据驱动开发的思想</p><p>html标签化的模板，模块化思想</p><p>数据绑定，控制器，依赖注入，</p><p>服务，指令，过滤器…</p><p>优点： 比较完善规范，文档、社区比较活跃</p><p>模块清晰，代码明了</p><p>缺点： 功能规范太固定，开发发挥空间小。</p><p>相对react和vue，不够轻量化</p><p>扩展性不够灵活</p><p>react</p><p>特点： 强大的组件化思想，任意封装、组合</p><p>独创JSX语法，virtual dom智能patch，灵活高效</p><p>轻量，易扩展，模块清晰，代码明了</p><p>社区生态完善，组件库、插件库丰富</p><p>缺点： 组件难以在复杂交互场景复用</p><p>侧重于做组件，做view展示层，对于业务逻辑等封装治理不如angular强大</p><p>JSX中html模板不够完备和健壮，比如一些属性变换写法，绑定事件大小写</p><p>vue</p><p>特点： 文档丰富，容易上手</p><p>模板较完备，声明式渲染，插值表达式与指令系统，</p><p>事件处理器，修饰符，计算属性 ，简单易用，功能强</p><p>社区生态完善，组件库、插件库丰富</p><p>缺点： 轻量框架使用是要结合生态插件组件使用，项目初始配置比较麻烦，</p><p>不过可以参考各种场景的标准模板配置，很多脚手架</p><p>声明式渲染与命令式渲染：  这个涉及到函数式编程中的一个声明式编程和命令式编程的概念。</p><p>比如命令式编程：</p><pre><code>let a = []
for(let i=0; i&lt; 10; i++){
  a.push(i*10)
}
</code></pre><p>声明式编程：</p><pre><code>let a = []
arr.forEach(i=&gt;{
a.push(i*10)
})
</code></pre><p>声明式编程隐藏了函数处理细节，命令式编程则需要处理细节。</p><p>声明式编程的好处是简单化，易于理解，减少劳动量。比如vue中的指令绑定事件，绑定属性都是这样。@click，:title等等，用的时候很方便，这正是声明式编程最直观的好处。</p><h3 id=8你了解的es6只是constletpromise吗你考虑过es6提出的真正趋势吗>8.你了解的ES6只是const、let、promise吗？你考虑过ES6提出的真正趋势吗？ <a href=#8%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84es6%e5%8f%aa%e6%98%afconstletpromise%e5%90%97%e4%bd%a0%e8%80%83%e8%99%91%e8%bf%87es6%e6%8f%90%e5%87%ba%e7%9a%84%e7%9c%9f%e6%ad%a3%e8%b6%8b%e5%8a%bf%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p>怎么可能，我又不是你。ES6中最常用的像变量定义这部分用let、const可以避免一些坑，异步处理可以用promise，不过我到喜欢用async/await 更简洁好用。</p><ul><li>还有简写的箭头函数，代码看起来更清晰。</li><li>“…” 变量析构和组装， 函数默认值</li><li>“模板字符串，便于字符拼接；标签模板 功能</li><li>Object对象的扩展， for in， Object.keys</li><li>Set和Map</li><li>class和module相关</li></ul><p>发展趋势： 总体来说<a href=https://www.w3cdoc.com>前端</a>开发更规范，更简单，语法更完备和成熟。支持的功能增强，开发效率提升，体验增强。</p><ul><li>ES6的模块化相关支持，可以更好地支持模块化开发。</li><li>原生支持class，面向对象的编程，概念更容易理解，易于软件开发和集成。</li><li>异步操作规范化，异步编程更简单</li></ul><h3 id=9你会用less那么让你去写一个loader你可以吗>9.你会用less，那么让你去写一个loader你可以吗？ <a href=#9%e4%bd%a0%e4%bc%9a%e7%94%a8less%e9%82%a3%e4%b9%88%e8%ae%a9%e4%bd%a0%e5%8e%bb%e5%86%99%e4%b8%80%e4%b8%aaloader%e4%bd%a0%e5%8f%af%e4%bb%a5%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p>参考下：<a href=https://www.f2e123.com/javascriptnodejs/1867.html>程序语言进阶之DSL与AST实战解析</a></p><p>可以的，说一下原理，需要将 .less 文件最终解析成CSS，less是一种DSL，<a href=https://www.w3cdoc.com>我们</a>可以现根据less预发，先将其解析成AST，然后解析成CSS即可。 我推荐用PEG.js这种解析表达式语法更简单些，只需要描述产生式规则即可。也可以自己根据LESS预发来写正则表达来匹配规则，然后转换成css。比较常用的是PostCSS，处理流程如下：<a href=https://github.com/postcss/postcss/blob/master/docs/architecture.md>参考官方文档</a></p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-38-01.png></p><p>PostCSS的处理流程也是经过词法解析语法分析，将读取到的文件字符转化成词汇流tokens，根据语法分析，根据less的语法，解析成一个AST。</p><p><em>source string → tokens → AST</em></p><p>核心组件有：</p><ul><li>词法分析器 Tokenizer ( <a href=https://github.com/postcss/postcss/blob/master/lib/tokenize.es6>lib/tokenize.es6</a> )</li><li>语法分析器 Parser ( <a href=https://github.com/postcss/postcss/blob/master/lib/parse.es6>lib/parse.es6</a>, <a href=https://github.com/postcss/postcss/blob/master/lib/parser.es6>lib/parser.es6</a> )</li><li>插件处理器 Processor ( <a href=https://github.com/postcss/postcss/blob/master/lib/processor.es6>lib/processor.es6</a> )</li><li>代码生成器 Stringifier ( <a href=https://github.com/postcss/postcss/blob/master/lib/stringify.es6>lib/stringify.es6</a>, <a href=https://github.com/postcss/postcss/blob/master/lib/stringifier.es6>lib/stringifier.es6</a> )</li></ul><h3 id=10webpack你也会用你了解其中原理吗你知道分析打包依赖的过程吗你知道tree-shaking是如何干掉无用重复的代码的吗>10.webpack你也会用，你了解其中原理吗？你知道分析打包依赖的过程吗？你知道tree-shaking是如何干掉无用重复的代码的吗？ <a href=#10webpack%e4%bd%a0%e4%b9%9f%e4%bc%9a%e7%94%a8%e4%bd%a0%e4%ba%86%e8%a7%a3%e5%85%b6%e4%b8%ad%e5%8e%9f%e7%90%86%e5%90%97%e4%bd%a0%e7%9f%a5%e9%81%93%e5%88%86%e6%9e%90%e6%89%93%e5%8c%85%e4%be%9d%e8%b5%96%e7%9a%84%e8%bf%87%e7%a8%8b%e5%90%97%e4%bd%a0%e7%9f%a5%e9%81%93tree-shaking%e6%98%af%e5%a6%82%e4%bd%95%e5%b9%b2%e6%8e%89%e6%97%a0%e7%94%a8%e9%87%8d%e5%a4%8d%e7%9a%84%e4%bb%a3%e7%a0%81%e7%9a%84%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p><a href=https://www.w3cdoc.com>大家</a>之前应该用过gulp，grunt这种代码打包工具，定义不同的打包任务和打包流程。我用的比较多的rollup这个打包工具，配置起来比较简单些。</p><p>webpack也是用来做代码打包，可以做代码分析，拆分，混淆，压缩等等，基于他的插件扩展机制可以做很多事情。分析webpack的原理，可以先从webpack配置文件说起。参考：<a href=https://www.f2e123.com/javascriptnodejs/4453.html>webpack编译代码原理介绍</a> <a href=https://www.f2e123.com/javascriptnodejs/4377.html>用webpack4和一些插件提升代码编译速度</a></p><p>首先作为打包工具，要定义打包的输入entry和输出output；然后是定义webpack要用到的module，比如babel js loader， cssloader等等。执行编译具体的流程是：</p><p>加载webpack配置文件 -》 根据配置初始化编译器compiler -》找到入口，根据loader配置开始编译入口文件以及层层依赖 -》编译完成之后，可以得到所有编译过的文件和依赖关系结构 -》根据依赖关系将模块组装成一个个包含多个模块的chunk，然后根据配置写到输出文件。</p><p>webpack构建流程可分为以下三大阶段。</p><ol><li>初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler</li><li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理</li><li>输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中</li></ol><p>分析依赖是在编译过程中完成的，从入口查找依赖，最后形成依赖关系。 为了提高效率，可以记录分析过的依赖，这样下次遇到同样的模块就不用再分析，直接引用编译过的依赖就可以了。</p><p>tree-shaking的名字原理一样，就是摇一摇大树，落下来的叶子都是冗余的部分。Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解。</p><p>tree shaking的目的是去掉无用代码，减少代码体积。其实对于编译的编程语言对应的编译器基本都有判断哪些代码不会影响输出，从而在编译时移除这些代码的功能，称为DCE（dead code elimination）。tree shaking 是DCE的一种实现，传统的是消除没有引用不会执行的代码，tree shaking 主要是要消除没有用的代码。</p><p>Dead Code 一般具有以下几个特征</p><p>•代码不会被执行，不可到达</p><p>•代码执行的结果不会被用到</p><p>•代码只会影响死变量（只写不读）</p><p>在<a href=https://www.w3cdoc.com>前端</a>代码打包处理中，最终都会有个代码压缩混淆的环节，这个环节其实会完成DCE的工作，会将这些dead code移除。</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-38-14.png></p><p>但是uglify代码是只是单个单个文件处理，并不能分析出这个代码有没有被其他文件用到，当然也不会对这些为被调用的函数做处理，如上图uglify就不会去除没用到的get函数，所以就需要tree shaking。tree shaking是有限制的，只能消除函数和import/export的变量，不会处理import/export的class（因为javascript动态语言特性使得分析比较困难，可能导致以外的错误，side effect比较大）， 对于纯函数处理效果较好。</p><h3 id=11你真的熟练使用css吗那你知道position有几个属性吗>11.你真的熟练使用css吗，那你知道position有几个属性吗 <a href=#11%e4%bd%a0%e7%9c%9f%e7%9a%84%e7%86%9f%e7%bb%83%e4%bd%bf%e7%94%a8css%e5%90%97%e9%82%a3%e4%bd%a0%e7%9f%a5%e9%81%93position%e6%9c%89%e5%87%a0%e4%b8%aa%e5%b1%9e%e6%80%a7%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p>具体参考<a href=https://github.com/wintercn/blog/issues/4 target=_blank rel="nofollow noopener noreferrer">https://github.com/wintercn/b…</a></p><ul><li>static：无特殊定位，对象遵循正常文档流。top，right，bottom，left等属性不会被应用。</li><li>relative：对象遵循正常文档流，但将依据top，right，bottom，left等属性在正常文档流中偏移位置，<strong>相对定位相对的是它原本在文档流中的位置而进行的偏移</strong>。而其层叠通过z-index属性定义。<em>占据的文档空间不会随 top / right / left / bottom 等属性的偏移而发生变动，也就是说它后面的元素是依据( top / left / right / bottom 等属性生效之前)进行的定位</em>，这点一定要理解。</li><li>absolute：对象脱离正常文档流，使用top，right，bottom，left等属性进行绝对定位。而其层叠通过z-index属性定义。使用absoulte或fixed定位的话，必须指定 left、right、 top、 bottom 属性中的至少一个，否则left/right/top/bottom属性会使用它们的默认值 auto ，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative，会占用文档空间，这点非常重要，很多人使用absolute定位后发现没有脱离文档流就是这个原因。</li><li>fixed：对象脱离正常文档流，使用top，right，bottom，left等属性以窗口为参考点进行定位，当出现滚动条时，对象不会随着滚动。而其层叠通过z-index属性定义。</li><li>sticky: The element is positioned according to the normal flow of the document, and then offset relative to its_nearest scrolling ancestor_and <a href=https://developer.mozilla.org/en-US/docs/Web/CSS/All_About_The_Containing_Block>containing block</a> (nearest block-level ancestor), including table-related elements, based on the values of <code>top</code>, <code>right</code>, <code>bottom</code>, and <code>left</code>. The offset does not affect the position of any other elements.This value always creates a new <a class=new href=https://developer.mozilla.org/en/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context rel=nofollow>stacking context</a>. Note that a sticky element “sticks” to its nearest ancestor that has a “scrolling mechanism” (created when <code>overflow</code> is <code>hidden</code>, <code>scroll</code>, <code>auto</code>, or <code>overlay</code>), even if that ancestor isn’t the nearest actually scrolling ancestor. This effectively inhibits any “sticky” behavior (see the <a class="external external-icon" href=https://github.com/w3c/csswg-drafts/issues/865 rel=noopener>Github issue on W3C CSSWG</a>).</li></ul><p>absolute就只能根据祖先类元素(父类以上)进行定位，而这个祖先类还必须是以postion非static方式定位的， 举个例子，a元素使用absoulte定位，它会从父类开始找起，寻找以position非static方式定位的祖先类元素(注意，一定要是直系祖先才算哦~），直到<html>标签为止，这里还需要注意的是，<strong>relative和static方式在最外层时是以<body>标签为定位原点的</strong>，而absoulte方式在无父级是position非static定位时是以<html>作为原点定位。</p><p>参考： <a href=https://blog.csdn.net/chen_zw/article/details/8741365>position属性</a></p><p>关于<a href=https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block>Layout and the containing block</a>，看下官方介绍的contain block，另外相关的点是 BFC：<a href=https://www.f2e123.com/question/ruhechuangjiankuaijigeshihuashangxiawenblock-formatting-contextbfcyoushenmeyong>如何创建块级格式化上下文(block formatting context),BFC有什么用</a></p><h3 id=115-前端httpswwww3cdoccom动画渲染机制了解吗硬件加速原理>11.5 <a href=https://www.w3cdoc.com>前端</a>动画渲染机制了解吗？硬件加速原理？ <a href=#115-%e5%89%8d%e7%ab%afhttpswwww3cdoccom%e5%8a%a8%e7%94%bb%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e5%90%97%e7%a1%ac%e4%bb%b6%e5%8a%a0%e9%80%9f%e5%8e%9f%e7%90%86 class=anchor aria-hidden=true>#</a></h3><p>参考：[<a href=https://www.w3cdoc.com>浏览器</a>渲染流水线解析与网页动画性能优化]<a href=https://www.f2e123.com/pwa/4474.html>26</a></p><p><strong>动画可以看做是一个连续的帧序列的组合</strong>。<a href=https://www.w3cdoc.com>我们</a>把网页的动画分成两大类 —— 一类是合成器动画，一类是非合成器动画（UC 内部也将其称为内核动画或者 Blink Animation，虽然这不是 Chrome 官方的术语）。</p><ol><li>合成器动画顾名思义，动画的每一帧都是由 Layer Compositor 生成并输出的，合成器自身驱动着整个动画的运行，在动画的过程中，不需要新的 Main Frame 输入；</li><li>非合成器动画，每一帧都是由 Blink 生成，都需要产生一个新的 Main Frame；</li></ol><p>合成器动画又可以分为两类：</p><ol><li>合成器本身触发并运行的，比如最常见的网页惯性滚动，包括整个网页或者某个页内可滚动元素的滚动；</li><li>Blink 触发然后交由合成器运行，比如说传统的 CSS Translation 或者新的 Animation API，如果它们触发的动画经由 Blink 判断可以交由合成器运行；</li></ol><blockquote><p>Blink 触发的动画，如果是 Transform 和 Opacity 属性的动画基本上都可以由合成器运行，因为它们没有改变图层的内容。不过即使可以交由合成器运行，它们也需要产生一个新的 Main Frame 提交给合成器来触发这个动画，如果这个 Main Frame 包含了大量的图层变更，也会导致触发的瞬间卡顿，页端事先对图层结构进行优化可以避免这个问题。</p></blockquote><p>非合成器动画也可以分为两类：</p><ol><li>使用 CSS Translation 或者 Animation API 创建的动画，但是无法由合成器运行；</li><li>使用 Timer 或者 rAF 由 JS 驱动的动画，比较典型的就是 Canvas/WebGL 游戏，这种动画实际上是由页端自己定义的，<a href=https://www.w3cdoc.com>浏览器</a>本身并没有对应的动画的概念，也就是说<a href=https://www.w3cdoc.com>浏览器</a>本身是不知道这个动画什么时候开始，是否正在运行，什么时候结束，这些完全是页端自己的内部逻辑；</li></ol><p>合成器动画和非合成器动画在渲染流水线上有较大的差异，后者更复杂，流水线更长。上面四种动画的分类，按渲染流水线的复杂程度和理论性能排列（复杂程度由低到高，理论性能由高到低）：</p><ol><li>合成器本身触发并运行的动画；</li><li>Blink 触发，合成器运行的动画；</li><li>Blink 触发，无法由合成器运行的动画；</li><li>由 Timer/rAF 驱动的 JS 动画；</li></ol><p>开启硬件加速的方法很多，比如transform: translate3d(0,0,0); 加了之后，在chrome开发者工具中的layer栏目下可以看到多了一层 composition layer，同时给出了理由描述是开启了3D transform，这个元素就放入了Composited Layer中托管，其动画效果都是在单独一个图形层上面处理，不会影响其它层。</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-38-29.png></p><p>什么情况下能使元素获得自己的层？虽然 Chrome 的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p><ul><li>3D 或透视变换(perspective transform) CSS 属性</li><li>使用加速视频解码的 元素</li><li>拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素</li><li>混合插件(如 Flash)</li><li>对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素</li><li>拥有加速 CSS 过滤器的元素</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><p>使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显。</p><p>关于层的介绍：<a href=http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome>gpu-accelerated-compositing-in-chrome</a></p><p><a href=https://www.f2e123.com/html5css3/3920.html>理解CSS animations 和 transitions的性能问题与动画调试</a></p><h3 id=12你了解js的数据结构吗基本数据类型有哪些复杂数据类型有哪些在内存是如何表现的>12.你了解js的数据结构吗？基本数据类型有哪些？复杂数据类型有哪些？在内存是如何表现的？ <a href=#12%e4%bd%a0%e4%ba%86%e8%a7%a3js%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%90%97%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b%e5%a4%8d%e6%9d%82%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b%e5%9c%a8%e5%86%85%e5%ad%98%e6%98%af%e5%a6%82%e4%bd%95%e8%a1%a8%e7%8e%b0%e7%9a%84 class=anchor aria-hidden=true>#</a></h3><p>参考<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures>MDN</a>，最新的 ECMAScript 标准定义了 7 种数据类型:</p><ul><li>6 种<a href=https://developer.mozilla.org/en-US/docs/Glossary/Primitive title="原始类型: In JavaScript, a primitive (primitive value, primitive data type) is data that is not an object and has no methods. There are 7 primitive data types: string, number, bigint, boolean, null, undefined, symbol (new in ECMAScript 2016).">原始类型</a>{.glossaryLink}:<ul><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Boolean title="Boolean: In computer science, a Boolean is a logical data type that can have only the values true or false.">Boolean</a>{.glossaryLink}</li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Null title="Null: In computer science, a null value represents a reference that points, generally intentionally, to a nonexistent or invalid object or address. The meaning of a null reference varies among language implementations.">Null</a>{.glossaryLink}</li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Undefined title="Undefined: undefined is a primitive value automatically assigned to variables that have just been declared, or to formal arguments for which there are no actual arguments.">Undefined</a>{.glossaryLink}</li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Number title="Number: In JavaScript, Number is a numeric data type in the double-precision 64-bit floating point format (IEEE 754). In other programming languages different numeric types can exist, for examples: Integers, Floats, Doubles, or Bignums.">Number</a>{.glossaryLink}</li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/String title="String: In any computer programming language, a string is a sequence of characters used to represent text.">String</a>{.glossaryLink}</li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Symbol title="Symbol: In JavaScript, Symbol is a primitive value.">Symbol</a>{.glossaryLink} (ECMAScript 6 新定义)</li></ul></li><li>和 <a href=https://developer.mozilla.org/en-US/docs/Glossary/Object title="Object: Object refers to a data structure containing data and instructions for working with the data. Objects sometimes refer to real-world things, for example a car or map object in a racing game. JavaScript, Java, C++, Python, and Ruby are examples of object-oriented programming languages.">Object</a>{.glossaryLink}</li></ul><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的。JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变。</p><h4 id=标准的_对象_和函数.highlight-spanned>标准的” 对象, 和函数【复杂数据类型】 <a href=#%e6%a0%87%e5%87%86%e7%9a%84_%e5%af%b9%e8%b1%a1_%e5%92%8c%e5%87%bd%e6%95%b0.highlight-spanned class=anchor aria-hidden=true>#</a></h4><p>日期：内建的 <a href=https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date>Date</a> 对象</p><p>数组和类型数组：</p><p><a href=https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array title=Array>数组</a>是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。此外，数组对象还继承了 Array.prototype 的一些操作数组的便捷方法。例如, <code>[indexOf][40] (搜索数组中的一个值) or</code><a href=https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push title=en/JavaScript/Reference/Global_Objects/Array/push>push</a> (向数组中添加一个元素)，等等。 这使得数组是表示列表或集合的最优选择。</p><p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays>类型数组(Typed Arrays)</a>是ECMAScript Edition 6中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图。</p><p>集合对象Map、WeakMap、Set、WeakSet：这些数据结构把对象的引用当作键，其在ECMAScript第6版中有介绍。当 <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map title="此页面仍未被本地化, 期待您的翻译!"><code>Map</code></a> 和 <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/WeakMap title="此页面仍未被本地化, 期待您的翻译!"><code>WeakMap</code></a> 把一个值和对象关联起来的时候， <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set title=Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。><code>Set</code></a> 和 <a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet title=WeakSet 对象允许你将弱保持对象存储在一个集合中。><code>WeakSet</code></a> 表示一组对象。 Map和WeakMaps之间的差别在于，在前者中，对象键是可枚举的。</p><p>结构化数据JSON：JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式</p><p>参考：<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects>标准全局内置对象</a></p><p><strong>两种类型：</strong></p><p>1. <wbr> <wbr> ECMAScript变量包含两种不同类型的值：基本类型值、引用类型值；</p><p>2. <wbr> <wbr> 基本类型值：指的是保存在栈内存中的简单数据段；</p><p>3. <wbr> <wbr> 引用类型值：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象；</p><p><strong>两种访问方式：</strong></p><p>4. <wbr> <wbr> 基本类型值：按值访问，操作的是他们实际保存的值；</p><p>5. <wbr> <wbr> 引用类型值：按引用访问，当查询时，<a href=https://www.w3cdoc.com>我们</a>需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值；</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-38-56.png></p><p>数据复制</p><p>基本类型变量的复制：从一个变量向一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的位置上；</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-07.png></p><ul><li>引用类型变量的复制：复制的是存储在栈中的指针，将指针复制到栈中未新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象；复制操作结束后，两个变量实际上将引用同一个对象；因此改变其中的一个，将影响另一个；</li></ul><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-17.png></p><p><strong>三种变量类型检测</strong></p><p>1. <wbr> <wbr> Typeof操作符是检测基本类型的最佳工具；</p><p>2. <wbr> <wbr> 如果变量值是null或者对象，typeof 将返回“object”；结合null == null 来判断</p><p>3. <wbr> <wbr> Instanceof用于检测引用类型，可以检测到具体的，它是什么类型的实例；</p><p>4. <wbr> <wbr> 如果变量是给定引用类型的实例，instanceof操作符会返回true;</p><ol><li>Object.prototype.toString.call(xx) 来打印原型判断类型</li></ol><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-25.png></p><h3 id=13你可以用js去实现一个单向双向循环链表吗你可以实现查找插入删除操作吗>13.你可以用js去实现一个单向、双向、循环链表吗？你可以实现查找、插入、删除操作吗？ <a href=#13%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%94%a8js%e5%8e%bb%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e5%8d%95%e5%90%91%e5%8f%8c%e5%90%91%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8%e5%90%97%e4%bd%a0%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e6%9f%a5%e6%89%be%e6%8f%92%e5%85%a5%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p>可以在这里试一下：<a href="https://www.f2e123.com/code?code=algorithm&pid=4330">在线编程环境</a></p><p>链表：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-33.png></p><p>插入链表节点：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-49.png></p><p>删除链表节点：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-39-55.png></p><p>双向链表：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-40-02.png></p><p>循环链表：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-40-08.png></p><p>下面给一个最简单的单项链表示例：</p><pre><code>/**
** 先创建一个节点类，记录当前数据，和下个节点，如果是双向链表，就包含prev
**prev: 对上个节点的引用
** next: 对下个节点的应用
**/
class Node{
  constructor(data){
    this.data = data;
    this.next = null;
  }
}
/**
**创建链表，head是链表中的一个起始节点，关于单项链表，双向链表和循环链表参考文章介绍
** find: 找到数据所在的节点，这里是示例，其实应该有个唯一标识
**insert: 在指定节点后面插入节点
**/
class LinkTable{
  constructor(data){
    this.head = null;
    this.end = null;
    if(data){
      this.head = new Node(data)
    }
  }
  find(data){
    let start = this.head;
    while(start.data != data){
      start = start.next;
    }
    return start;
  }
  // 倒序插入节点
  insert(data){
    let nod = new Node(data);
    nod.next = this.head
    this.head = nod;
  }
}

</code></pre><p>参考这里：https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph</p><h3 id=14你了解基本常见算法吗快速排序写一个要是限制空间利用你该如何写>14.你了解基本常见算法吗？快速排序写一个？要是限制空间利用你该如何写？ <a href=#14%e4%bd%a0%e4%ba%86%e8%a7%a3%e5%9f%ba%e6%9c%ac%e5%b8%b8%e8%a7%81%e7%ae%97%e6%b3%95%e5%90%97%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e5%86%99%e4%b8%80%e4%b8%aa%e8%a6%81%e6%98%af%e9%99%90%e5%88%b6%e7%a9%ba%e9%97%b4%e5%88%a9%e7%94%a8%e4%bd%a0%e8%af%a5%e5%a6%82%e4%bd%95%e5%86%99 class=anchor aria-hidden=true>#</a></h3><p>快速排序：</p><p>（1）在数据集之中，选择一个元素作为”基准”（pivot）。</p><p>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</p><p>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><p>选择排序：</p><p>（1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p><p>（2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</p><p>（3）直到所有都排序</p><p>冒泡排序：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>直接插入排序：</p><p>（1）将待排序数组取一个数值插入到已排序数组中合适的位置</p><p>（2）重复取数据，直到所有数据取完</p><h3 id=15你了解贪心算法动态规划分治算法回溯算法等常见的算法吗>15.你了解贪心算法、动态规划、分治算法、回溯算法等常见的算法吗？ <a href=#15%e4%bd%a0%e4%ba%86%e8%a7%a3%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95%e7%ad%89%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ae%97%e6%b3%95%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p><a id=cb_post_title_url class=postTitle2 href=https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html>分治算法</a></p><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>分治法所能解决的问题一般具有以下几个特征：</p><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ol><div><a id=cb_post_title_url class=postTitle2 href=https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html>贪心算法</a></div><p> 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>     贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>    所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><ul><li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li></ul><div>贪心算法的基本思路：</div><div>    1.建立数学模型来描述问题。</div><div>    2.把求解的问题分成若干个子问题。</div><div>    3.对每一子问题求解，得到子问题的局部最优解。</div><div>    4.把子问题的解局部最优解合成原来解问题的一个解。</div><p><a id=cb_post_title_url class=postTitle2 href=https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html>动态规划算法</a></p><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><p>    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><p>能采用动态规划求解的问题的一般要具有3个性质：</p><p>    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>   （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><p><a id=cb_post_title_url class=postTitle2 href=https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html>回溯法</a></p><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）</p><p><a id=cb_post_title_url class=postTitle2 href=https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741378.html>分支限界法</a></p><p>类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><p>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p><h3 id=16你是如何理解前端httpswwww3cdoccom架构的你了解持续集成吗>16.你是如何理解<a href=https://www.w3cdoc.com>前端</a>架构的？你了解持续集成吗？ <a href=#16%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3%e5%89%8d%e7%ab%afhttpswwww3cdoccom%e6%9e%b6%e6%9e%84%e7%9a%84%e4%bd%a0%e4%ba%86%e8%a7%a3%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e5%90%97 class=anchor aria-hidden=true>#</a></h3><p>架构，我理解主要做：系统分解、服务分层的工作。</p><p><a href=http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html>持续集成</a> （Continuous integration，简称CI）。项目是一个迭代一个迭代快速开发，每个迭代开发不同的feature，所有的feature合在一起构成完整的功能。</p><p>**持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。**它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>Martin Fowler说过，”持续集成并不能消除Bug，而是让它们非常容易发现和改正。”</p><p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p><h3 id=17你了解基本的设计模式吗举例单例模式策略模式代理模式迭代模式发布订阅模式>17.你了解基本的设计模式吗？举例单例模式、策略模式、代理模式、迭代模式、发布订阅模式。。。？ <a href=#17%e4%bd%a0%e4%ba%86%e8%a7%a3%e5%9f%ba%e6%9c%ac%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%90%97%e4%b8%be%e4%be%8b%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f%e8%bf%ad%e4%bb%a3%e6%a8%a1%e5%bc%8f%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f class=anchor aria-hidden=true>#</a></h3><p><a href=https://www.runoob.com/design-pattern/singleton-pattern.html>设计模式（Design pattern）</a>代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。</p><p><a href=https://www.runoob.com/design-pattern/singleton-pattern.html>单例模式：</a></p><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><pre><code>class Singleton{
  static getInstance(){
    if(!this.ins) this.ins = 1;
    return this.ins;
  }
}
console.log(Singleton.getInstance())
class Singleton{
  constructor(){
    this.ins = 1;
  }
  getInstance(){
    return this.ins;
  }
}
console.log(new Singleton().getInstance())
</code></pre><p><a href=https://www.runoob.com/design-pattern/strategy-pattern.html>策略模式</a></p><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，<a href=https://www.w3cdoc.com>我们</a>创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p>很好理解，比如上面给的一个异常处理的代码，写个简单的示例。</p><pre><code>export class RuntimeException {

    constructor(message) {
        this._message = message;
    }

    get name() {
        return 'RuntimeException';
    }

    get message() {
        return this._message;
    }

    toString() {
        return this.name + ': ' + this.message;
    }

}

export class IllegalStateException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'IllegalStateException';
    }

}

export class InvalidArgumentException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'InvalidArgumentException';
    }

}

export class NotImplementedException extends RuntimeException {

    constructor(message) {
        super(message);
    }

    get name() {
        return 'NotImplementedException';
    }

}

export function funcWrapper(args){
    try{
      if(!args) throw new InvalidArgumentException('args undefined')
      if(args == 1) throw new IllegalStateException('args illegal')
    }catch(e){
        console.log(e.toString())
    }
}

</code></pre><p><a href=https://www.w3cdoc.com>浏览器</a>可以跑下结果看看：</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-41-13.png></p><p>这就是策略模式，不同的情况，输出的结果是不一样的。</p><p><a href=https://www.runoob.com/design-pattern/proxy-pattern.html>代理模式</a></p><h3 id=18写一个事件监听函数呗实现onceonremoveemit功能>18.写一个事件监听函数呗？实现once、on、remove、emit功能 <a href=#18%e5%86%99%e4%b8%80%e4%b8%aa%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%87%bd%e6%95%b0%e5%91%97%e5%ae%9e%e7%8e%b0onceonremoveemit%e5%8a%9f%e8%83%bd class=anchor aria-hidden=true>#</a></h3><h3 id=19nodejs的实现层是什么>19.node.js的实现层是什么？ <a href=#19nodejs%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%b1%82%e6%98%af%e4%bb%80%e4%b9%88 class=anchor aria-hidden=true>#</a></h3><h3 id=20node的事件循环机制是怎样的node的child_process模块有几个api分别的作用是什么>20.node的事件循环机制是怎样的？node的child_process模块有几个api,分别的作用是什么？ <a href=#20node%e7%9a%84%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84node%e7%9a%84child_process%e6%a8%a1%e5%9d%97%e6%9c%89%e5%87%a0%e4%b8%aaapi%e5%88%86%e5%88%ab%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 class=anchor aria-hidden=true>#</a></h3><p>在node中，事件循环表现出的状态与<a href=https://www.w3cdoc.com>浏览器</a>中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。<a href=https://www.w3cdoc.com>我们</a>知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。下面是一个libuv引擎中的事件循环的模型:</p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-41-21.png></p><p><em>注：模型中的每一个方块代表事件循环的一个阶段</em></p><p>这个模型是node官网上的一篇文章中给出的，我下面的解释也都来源于这篇文章。我会在文末把文章地址贴出来，有兴趣的朋友可以亲自与看看原文。</p><p><a href=https://www.w3cdoc.com>我们</a>知道Linux中有个高效多路IO复用的poll/select模型，增强改进有个epoll模型。<a href=https://segmentfault.com/a/1190000003063859>参考这里</a></p><p>上面这个node的poll模型中，<a href=https://www.w3cdoc.com>我们</a>可以大致分析出node中的事件循环的顺序：</p><p>外部输入数据->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timer)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段…</p><p>以上各阶段的名称是根据我个人理解的翻译，为了避免错误和歧义，下面解释的时候会用英文来表示这些阶段。</p><p>这些阶段大致的功能如下：</p><ul><li>timers: 这个阶段执行定时器队列中的回调如 <code>setTimeout()</code> 和 <code>setInterval()</code>。</li><li>I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和<code>setImmediate()</code>的回调。</li><li>idle, prepare: 这个阶段仅在内部使用，可以不必理会。</li><li>poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。</li><li>check: <code>setImmediate()</code>的回调会在这个阶段执行。</li><li>close callbacks: 例如<code>socket.on('close', ...)</code>这种close事件的回调。</li></ul><p>详情参考：[<a href=https://www.w3cdoc.com>浏览器</a>与node环境的事件循环机制]<a href=https://www.f2e123.com/javascriptnodejs/4734.html>53</a></p><h3 id=22http10与11协议的区别node是如何实现http模块的>22.http1.0与1.1协议的区别？node是如何实现http模块的？ <a href=#22http10%e4%b8%8e11%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%8c%ba%e5%88%abnode%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0http%e6%a8%a1%e5%9d%97%e7%9a%84 class=anchor aria-hidden=true>#</a></h3><h3 id=25nginx相关配置了解过吗>25.nginx相关配置了解过吗？ <a href=#25nginx%e7%9b%b8%e5%85%b3%e9%85%8d%e7%bd%ae%e4%ba%86%e8%a7%a3%e8%bf%87%e5%90%97 class=anchor aria-hidden=true>#</a></h3><h3 id=27小程序架构>27.小程序架构 <a href=#27%e5%b0%8f%e7%a8%8b%e5%ba%8f%e6%9e%b6%e6%9e%84 class=anchor aria-hidden=true>#</a></h3><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-41-30.png></p><p><img class="img-fluid lazyload blur-up" src=/images/posts/2023-01-02-20-41-37.png></p><h3 id=28vue-v-model-语法糖vue-push式更新vue-computed和watch的区别>28. vue v-model 语法糖？vue push式更新？vue computed和watch的区别？ <a href=#28vue-v-model-%e8%af%ad%e6%b3%95%e7%b3%96vue-push%e5%bc%8f%e6%9b%b4%e6%96%b0vue-computed%e5%92%8cwatch%e7%9a%84%e5%8c%ba%e5%88%ab class=anchor aria-hidden=true>#</a></h3><h3 id=29-redux-dispatch一个action之后的更新过程>29. redux dispatch一个action之后的更新过程 <a href=#29-redux-dispatch%e4%b8%80%e4%b8%aaaction%e4%b9%8b%e5%90%8e%e7%9a%84%e6%9b%b4%e6%96%b0%e8%bf%87%e7%a8%8b class=anchor aria-hidden=true>#</a></h3><p>知道connect的时候出于性能优化的考虑做了一层浅比较。</p><h3 id=30假设页面有多个模块每个模块都用到了getuser方法获取用户信息怎么设计通用的getuser避免发出多次请求>30.假设页面有多个模块，每个模块都用到了getUser方法获取用户信息，怎么设计通用的getUser避免发出多次请求。 <a href=#30%e5%81%87%e8%ae%be%e9%a1%b5%e9%9d%a2%e6%9c%89%e5%a4%9a%e4%b8%aa%e6%a8%a1%e5%9d%97%e6%af%8f%e4%b8%aa%e6%a8%a1%e5%9d%97%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86getuser%e6%96%b9%e6%b3%95%e8%8e%b7%e5%8f%96%e7%94%a8%e6%88%b7%e4%bf%a1%e6%81%af%e6%80%8e%e4%b9%88%e8%ae%be%e8%ae%a1%e9%80%9a%e7%94%a8%e7%9a%84getuser%e9%81%bf%e5%85%8d%e5%8f%91%e5%87%ba%e5%a4%9a%e6%ac%a1%e8%af%b7%e6%b1%82 class=anchor aria-hidden=true>#</a></h3><p>这个是一个朋友给的网易考拉<a href=https://www.w3cdoc.com>前端</a>的面试题，朋友给了2个解法：</p><ul><li>监听者模式，监听getUser事件，第一次注册监听事件时发出请求，待请求数据回来，执行所有回调。通过事件监听解耦。</li><li>基于promise，getUser方法提供一个thenable的能力，返回一个promise对象，在Promise中将resolve维护在一个resolveList列表中，其实和事件监听中的事件列表类似。第一次调用时发出请求，请求回来后调用resolveList列表中所有resolve。</li></ul><p>个人感觉基于promise的方法比事件监听模式更优，本来就是一步的操作返回的也是一个Promise，更符合编码逻辑。</p><div class="page-footer-meta d-flex flex-column flex-md-row justify-content-between"></div><div class="docs-navigation d-flex justify-content-between"><a href=/fed-regain/algorithm/%E6%9F%A5%E6%89%BE%E7%AC%AC-k-%E5%A4%A7%E5%85%83%E7%B4%A0/><div class="card my-1"><div class="card-body py-2">&larr; 查找第 k 大元素</div></div></a><a class=ms-auto href=/fed-regain/algorithm/%E6%A3%80%E9%AA%8C%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2/><div class="card my-1"><div class="card-body py-2">检验是否为另一个字符串循环移动后的子串 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Copyright © 2022-Present 浙ICP备18052292号-3</li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline></ul></div></div></div></footer><script src=/js/bootstrap.min.1117772738b0b01188ff56b000f75758d3ca75fab55d0d7cf813282148e4840455e1fc0a8f1c2951391282de6e64bed66b885160643382a58f67db6d110e9feb.js integrity="sha512-ERd3JziwsBGI/1awAPdXWNPKdfq1XQ18+BMoIUjkhARV4fwKjxwpUTkSgt5uZL7Wa4hRYGQzgqWPZ9ttEQ6f6w==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.35e8488ad0bca08539c53f48a94a3c02f90c10ddc1ecba4a7fd7ec827cef556dec98a33813e3681b33a5750eefd53e65ab606d30febc27e411c293f2290f96a5.js integrity="sha512-NehIitC8oIU5xT9IqUo8AvkMEN3B7LpKf9fsgnzvVW3smKM4E+NoGzOldQ7v1T5lq2BtMP68J+QRwpPyKQ+WpQ==" crossorigin=anonymous defer></script>
<script src=/main.min.5874482df6978e314928bf4ce1c634b6464aa5445dd098e344aa61159e2b10139d82662edd47e835a3ea422c24214134f15eded85f28e55774a70f9c4919b2b3.js integrity="sha512-WHRILfaXjjFJKL9M4cY0tkZKpURd0JjjRKphFZ4rEBOdgmYu3UfoNaPqQiwkIUE08V7e2F8o5Vd0pw+cSRmysw==" crossorigin=anonymous defer></script>
<script src=/index.min.4ae26272486ea46c5bb0bed7a0b434a91b05e8182cfb839a405dd4e647b05ce5d76d401a5103d822d3b1589fc56335cd372b712d97085b8d89aebf244b1b5501.js integrity="sha512-SuJickhupGxbsL7XoLQ0qRsF6Bgs+4OaQF3U5kewXOXXbUAaUQPYItOxWJ/FYzXNNytxLZcIW42Jrr8kSxtVAQ==" crossorigin=anonymous defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML" async></script>
<script type="text/x-mathjax-config;executed=true">
  window.MathJax.Hub.Config({
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
          displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
          skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
          availableFonts: ["STIX", "TeX"], //可选字体
          showMathMenu: false //关闭右击菜单显示
      }
  });
  //下面第三个参数可以不写，默认对整个html内的latex进行翻译
  window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementsByClassName("ck-content")]);
</script></body></html>