<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>node on</title><link>/fed-regain/node/</link><description>Recent content in node on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:15 +0000</lastBuildDate><atom:link href="/fed-regain/node/index.xml" rel="self" type="application/rss+xml"/><item><title>Egg入门学习—理解中间件作用</title><link>/fed-regain/node/egg%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%9C%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/egg%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%9C%E7%94%A8/</guid><description>Egg是基于koa的，因此Egg的中间件和Koa的中间件是类似的。都是基于洋葱圈模型的。
在Egg中，比如我想禁用某些IP地址来访问我们的网页的时候，在egg.js中我们可以使用中间件来实现这个功能，中间件的作用无非就是说在Egg的外层在包一层来判断某些事情是否符合要求，也就是在洋葱圈模型外面再进行包一层。
在Egg中，中间件也有自己的配置和目录，因此在Egg中约定了中间件是放在 app/middleware 目录中的文件。该文件需要exports一个普通的function. 因此整个项目的目录变成如下这个样子：
``` egg-demo2 ├── app │ ├── controller # 用于解析用户的输入，处理后返回响应的结果 │ │ └── home.js | | |-- index.js │ └── router.js # 用于配置url路由的配置规则 │ ├──public # 资源文件目录 | | |---css | | | |-- index.css | | |---js | | | |-- index.js | |--- view # 存放模板文件的目录 | | |-- index | | | |-- list.tpl（模板文件list） | |--- service # 编写业务逻辑的目录 | | |--- index.</description></item><item><title>egg理解service使用</title><link>/fed-regain/node/egg%E7%90%86%E8%A7%A3service%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/egg%E7%90%86%E8%A7%A3service%E4%BD%BF%E7%94%A8/</guid><description>这篇文章我们首先来看看官网对Egg的整个框架的约定如下，及约定对应的目录是做什么的，来有个简单的理解，注意：我也是按照官网的来理解的。
``` egg-project ├── package.json ├── app.js (可选) ├── app | ├── router.js │ ├── controller │ | └── home.js │ ├── service (可选) │ | └── user.js │ ├── middleware (可选) │ | └── xxx.js │ ├── schedule (可选) │ | └── xxx.js │ ├── public (可选) │ | └── reset.css │ ├── view (可选) │ | └── home.tpl │ └── extend (可选) │ ├── helper.js (可选) │ ├── request.</description></item><item><title>Node.js 代码规范约定</title><link>/fed-regain/node/node.js-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BA%A6%E5%AE%9A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/node.js-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BA%A6%E5%AE%9A/</guid><description>Node.js 代码规范 # 这里只是简单约定，并不是强制。
空格缩进 使用2个空格而不是 tab 来进行代码缩进，同时绝对不要混用空格和 tab 。 Sublime Text 2 设置(Preferences &amp;gt; Settings - User)：
&amp;quot;tab_size&amp;quot;: 2, &amp;quot;translate_tabs_to_spaces&amp;quot;: true 换行 使用 UNIX 风格的换行符 (\n)，同时在每个文件的结尾添加一个换行符。 Windows 风格的换行符 (\r\n) 是绝对禁止出现在任何项目中的。 Sublime Text 2 设置(Preferences &amp;gt; Settings - User)：
&amp;quot;default_line_ending&amp;quot;: &amp;quot;unix&amp;quot; 去除行末尾的多余空格 就像吃完饭要刷牙一样，在提交 (commit) 代码之前你需要清理掉所有的不必要的空格。 Sublime Text2 设置(Preferences &amp;gt; Settings - User)：
&amp;quot;trim_trailing_white_space_on_save&amp;quot;: true 使用分号 是否使用分号，在社区争论已久. isaac 也写过一篇讨论的文章, 但是，当可以用廉价的语法来消除一些可能引入的错误的时候，请当一个保守派。 每行80个字符 限制你每行代码不超过80个字符。尽管现在的显示器越来越大，但是你的大脑并没有变大，并且你还可以把你的大显示器切分成多屏来显示。 Sublime Text 2 设置(Preferences &amp;gt; Settings - User)：
&amp;quot;rulers&amp;quot;: [80] 多屏：view &amp;gt; Layout &amp;gt; Columns 2</description></item><item><title>NodeJS Express运行实例</title><link>/fed-regain/node/nodejs-express%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejs-express%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B/</guid><description>前言 # 最近在学NodeJS，其实以前学过，好长时间没有用，就忘记了。想想还是比较可惜的。最近学习也是从看资料开始，偶尔看到一些博客写的真的很不错。但是都是零零碎碎的。而且很多都是老版本的，按照博客的写法一步一步走过来，很多地方要么报错，要么都不能用。
自己也是找了很多资料，所以打算把这些更改的地方写一下，正确的写法记录一下，分享给想学的同学，让大家都少走弯路，节省学习成本。
转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2014/07/29/2014_nodejs_1/
安装NodeJS环境 # step1: 进入官网(https://www.nodejs.org/ )，下载安装包安装，本文作者用的是win8.1系统。windows系统会自动将nodeJS安装后的路径加到系统环境变量path中，如果你在cmd控制台输入：node，没有反应，则说明你的这个nodeJS目录没有添加到系统环境变量中，请手动添加。
我的nodeJS版本如下：
step2: 安装Express框架，Express是WEB开发框架，你可以认为类似java中的spring web mvc或者php中的thinkPHP，或者Ruby中的rails，或者python中的Django框架。利用这可框架可以大大提高开发效率，至于该框架的原理，后期高级课程在说明。我们先入为主，先有一些主观的概念。
安装方法及版本：
step3: 使用Express构建web项目
其中，-e是-ejs的缩写，指的是使用ejs模板，另外还有一种用的比较多的模板是jade，这里不做多介绍。上面的命令会自动创建项目工程目录nodetest，并自动生成package.json文件，然后我们进入改工程文件，然后安装依赖包。这样最简单的web项目就创建成功了。
step4： 安装supervisor
安装supervisor的优点是每次修改完代码之后，supervisor插件会自动应用更改，不用再手工部署。我们现在启动刚才的web工程。
step5： 打开浏览器访问（https://localhost:3000/ ），能看到express的欢迎信息，恭喜您，第一个web工程建好了。
项目目录结构 # ☞ node_modules, 存放所有的项目依赖库。(每个项目管理自己的依赖，与Maven,Gradle等不同)
☞ package.json，项目依赖配置及开发者信息
☞ app.js，程序启动文件
☞ public，静态文件(css,js,img)
☞ routes，路由文件(MVC中的C,controller)
☞ Views，页面文件(Ejs模板)
step6： 修改程序，ejs后缀的模板看着不爽，想改成html的，可以！修改：app.js
step7： 开发一个简单的登录页面，首先下载比较流行的bootstrap界面框架（https://www.bootcss.com/ ），分别将：
-css目录复制到public/stylesheets目录
-js目录复制到public/javascripts目录，需要添加jquery库
为了方便，我们将页面分为三个部分，头部head.html、内容部分login.html、底部信息栏foot.html
☞ head.html, 为html页面的头部区域
☞ index.html,home.html, 为内容显示区域
☞ foot.html，为页面底部区域
head.html
foot.html
index.html
home.html
login.html
编写路由规则 # step8: 打开app.js，发现有这么一行：
上面的语法意思是，拦截所有的根路径请求，交给routes处理，routes实际上是指index中定义的实例。我们这里只需要打开routes目录下的index文件，设置相应的路由规则。
routes/index.js
打开浏览器，你可以登录了。是不是很简单，下面学学session控制，将登录信息放到session中，便于共享数据。
使用SESSION传递参数 # 分析上面的程序：</description></item><item><title>NodeJS 网络爬虫</title><link>/fed-regain/node/nodejs-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejs-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid><description>前言 # 以前做网络爬虫都是用java开发，基于http client模拟请求，获取数据，然后基于正则表达式来提取需要的数据。这两天突然看见可以用NodeJS来做网络爬虫，而且最大的好处是，获取到的内容可以使用jQuery等库来解析操作dom，这个无疑对于数据提取是比较方便的。这里做个demo项目，作为以后应用的种子项目。
转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2014/07/29/2014_nodejs_2/
准备相关类库 # 大致规划如下：
web项目，基于express3, ejs模板 通过request抓取网页 通过jQuery, jsdom, htmlparser提取网页内容
首先按照 NodeJS Express运行实例上的方法创建一个Express工程。然后安装相应的依赖包。 安装jsdom # 执行如下命令安装，同时更新package.json
这个安装的时候可能会报如下错误：
这是由于缺少安装依赖环境。这里不只是jsdom，很多其他的插件包，很多也是需要这个依赖环境的。这个依赖环境其实就是一个编译环境，因为有些插件包是一源码形式发布的，安装时候需要对代码进行编译。所以这里需要安装：
python 2.7版本，这个版本最好不要太高。 Visual C++ 2010 Express，这个主要安装c++编译器 安装node-gyp编译插件，npm install -g node-gyp
然后就可以安装jsdom了。 安装jQuery，xmlhttprequest，request，htmlparser # 依次安装并更新package.json：
爬虫实例 # 假设我们现在要去官网爬取彩票的开奖数据，以百度乐彩(https://baidu.lecai.com/lottery/draw/?agentId=5571 )网站为例,我们要抓取双色球的开奖数据。
首先在项目目录下增加myUtil.js，代码如下：
然后修改 routes/index.js文件，代码如下：
这里我们已经把获取到的网页内容的content输出到了本地，启动应用，打开浏览器：https://127.0.0.1:3000 可以看见本地显示的和原网页的一模一样。然后我们就可以提取需要的内容。
首先通过使用浏览器调试开发工具（按F12），来查找我们需要的数据所在的位置。如下：
然后我们通过使用css选择器来选中这块内容，通过jquery来处理。修改routes/index.js
需要注意的是这里面，如果用css选择器，选中双色球的数据列表的选择器为_.ballbg:first-child_，但是使用jQuery的语法_$(‘.ballbg:first-child’)选取不到第一个列表数据，因为这里面有个区别，jQuery里面有自己的选择器，选取第一个元素是:first_，于是正确的jQuey选择器语句是_$(‘.ballbg:first’)_，执行结果：
然后就是提取其中的数据。
谢谢！ # 欢迎关注皓眸学问公众号（扫描左侧二维码），每天好文、新技术！任何学习疑问或者工作问题都可以给我留言、互动。T_T 皓眸大前端开发学习 T_T</description></item><item><title>NodeJS+mongoDB部署到Linux</title><link>/fed-regain/node/nodejsmongodb%E9%83%A8%E7%BD%B2%E5%88%B0linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejsmongodb%E9%83%A8%E7%BD%B2%E5%88%B0linux/</guid><description>部署需求 # 这几天把之前做的关于FIDO认证系统的DEMO程序部署到服务器上，想到去年买了一台Aliyun的服务器，应该还没有到期，所以就试着部署到服务器上。我的阿里云是RedHat 4.1.2的系统，使用起来还是很方便的。
转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2014/07/29/2014_nodejs_2/
linux安装nodejs和mongoDB # 安装nodejs # 很久之前安装过windows下以及Mac下的node，感觉还是很方便的，不成想今天安装linux下的坑了老半天，特此记录。首先去官网下载代码，这里一定要注意安装分两种，一种是Source Code源码，一种是编译后的文件（Binaries）。如下图所示，带Binaries的是编译好的文件。
（一） 编译好的文件
简单说就是解压后，在bin文件夹中已经存在node以及npm，如果你进入到对应文件的中执行命令行一点问题都没有，不过不是全局的，所以将这个设置为全局就好了。
这就妥妥的了，node文件夹具体放在哪，叫什么名字随你怎么定。然后设置全局：
这里/home/kun/mysofltware/这个路径是你自己放的，你将node文件解压到哪里就是哪里。
（二）通过源码编译
这种方式你下载的文件是Source code，我不太喜欢这种方式。。。主要是麻烦
查看当前安装的Node的版本
（三）apt-get
还有一种就是shell提示的apt-get方式，我之前就被这种方式坑了。。。强烈不推荐啊
安装mongoDB # 1）配置官方YUM源
64位机器源配置文件如下
其中，官方源中包括以下软件包
mongo-10gen 这个包包含了最新最稳定的mongodb工具 # mongo-server-10gen 这个包包含了最新最稳定版本的mongod和mongos守护进程及相关的配置和初始化脚本 # mongo18-10gen 这个包包含了之前发行版中的mongodb工具 # mongo18-server-10gen 这个包包含了前一个稳定版的mongod和mongos守护进程及相关的配置和初始化脚本 # 2）系统更新
3）安装mongodb
看到提示说明安装成功
4）配置mongodb
配置文件为：/etc/mongod.conf
初始化脚本为：/etc/rc.d/init.d/mongod
数据存储路径：/var/lib/mongo/
日志文件存储路径：/var/log/mongo/
守护进程运行用户为：mongod
以上均为默认值
5)Mongodb控制
加入开机启动
启动mongodb
停止mongodb
重启mongodb
nodejs后台运行 # 我们在linux中启动nodejs开发的程序后，希望web服务可以在后台运行，不会因为用户退出而停止服务。
有两种方式：
command &amp;amp; ： 后台运行，你关掉终端会停止运行 nohup command &amp;amp; ： 后台运行，你关掉终端也会继续运行 相关命令及知识 # Linux/Unix 区别于微软平台最大的优点就是真正的多用户，多任务。因此在任务管理上也有别具特色的管理思想。</description></item><item><title>nodejs入门阅读</title><link>/fed-regain/node/nodejs%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejs%E5%85%A5%E9%97%A8%E9%98%85%E8%AF%BB/</guid><description>Node入门 # 本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。 然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。（ps:本篇由互联网转载，如有侵犯，请和我联系）
本书结构 # 读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。
当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。
本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。
紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。
最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。
可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。
JavaScript与Node.js # JavaScript与你 # 抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。
如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。
而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。
与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是window.open() 那么简单。 .
不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。
然后，出现了Node.js，服务端的JavaScript，这有多酷啊？
于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。
问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。
因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。
当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。
本书的目标就是给你提供指导。
简短申明 # 业界有非常优秀的JavaScript程序员。而我并非其中一员。
我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。
因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。
如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。
服务端JavaScript # JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。
Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。
要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。
除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。
因此，Node.js事实上既是一个运行时环境，同时又是一个库。
要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。
“Hello World” # 好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。
打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：
保存该文件，并通过Node.js来执行：
正常的话，就会在终端输出Hello World 。
好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。
一个完整的基于Node.js的web应用用例 # 我们来把目标设定得简单点，不过也要够实际才行：
用户可以通过浏览器使用我们的应用。
当用户请求https://domain/start时，可以看到一个欢迎页面，页面上有一个文件上传的表单。
用户可以选择一个图片并提交表单，随后文件将被上传到https://domain/upload，该页面完成上传后会把图片显示在页面上。</description></item><item><title>nodejs子进程之child_process</title><link>/fed-regain/node/nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8Bchild_process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8Bchild_process/</guid><description>在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。熟悉shell脚本的同学，可以用它来完成很多有意思的事情，比如文件压缩、增量部署等，感兴趣的同学，看文本文后可以尝试下。
举个简单的例子：
const spawn = require('child_process').spawn; const ls = spawn('ls', ['-lh', '/usr']); ls.stdout.on('data', (data) =&amp;gt; { console.log(`stdout: ${data}`); }); ls.stderr.on('data', (data) =&amp;gt; { console.log(`stderr: ${data}`); }); ls.on('close', (code) =&amp;gt; { console.log(`child process exited with code ${code}`); }); 几种创建子进程的方式 # 注意事项：
下面列出来的都是异步创建子进程的方式，每一种方式都有对应的同步版本。 .exec()、.execFile()、.fork()底层都是通过.spawn()实现的。 .exec()、execFile()额外提供了回调，当子进程停止的时候执行。 child_process.spawn(command[, args][, options])
child_process.exec(command[, options][, callback])
child_process.execFile(file[, args][, options][, callback])
child_process.fork(modulePath[, args][, options])
child_process.exec(command[, options][, callback]) # 创建一个shell，然后在shell里执行命令。执行完成后，将stdout、stderr作为参数传入回调方法。
spawns a shell and runs a command within that shell, passing the stdout and stderr to a callback function when complete.</description></item><item><title>NodeJS的buffer使用总结</title><link>/fed-regain/node/nodejs%E7%9A%84buffer%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/nodejs%E7%9A%84buffer%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid><description>buffer拼接数据 # 写网页爬虫，或者读取文件流，接收网络数据流的时候，我们经常使用buffer来拼接接受的数据块。关于这个字符串拼接，在java中的字符流或者字节流是可以指定编码的，或者接收后转换编码，而在NodeJS中的处理就有些不同了。
转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2014/09/09/2014_nodejs_buffer/
字符串长度 # 看看PHP对字符串长度的判断结果：
以上三行判断分别返回10、30、10。对于中国人而言，strlen这个方法对于Unicode的判断结果是非常让人疑惑。而看看JavaScript中对字符串长度的判断，就知道这个length属性对调用者而言是多么友好。
尽管在计算机内部，一个中文字和一个英文字占用的字节位数是不同的，但对于用户而言，它们拥有相同的长度。我认为这是JavaScript中 String处理得精彩的一个点。正是由于这个原因，所有的数据从后端传输到前端被调用时，都是这般友好的字符串。所以对于前端工程师而言，他们是没有字符串Buffer的概念的。如果你是一名前端工程师，那么从此在与Node.js打交道的过程中，一定要小心Buffer啦，因为它比传统的String 要调皮一点。
Buffer使用 # 像许多计算机的技术一样，都是从国外传播过来的。那些以英文作为母语的传道者们应该没有考虑过英文以外的使用者，所以你有可能看到如下这样一段代码在向你描述如何在data事件中连接字符串。
如果这个文件读取流读取的是一个纯英文的文件，这段代码是能够正常输出的。但是如果我们再改变一下条件，将每次读取的buffer大小变成一个奇数，以模拟一个字符被分配在两个trunk中的场景。
我们将会得到以下这样的乱码输出：
造成这个问题的根源在于data += trunk语句里隐藏的错误，在默认的情况下，trunk是一个Buffer对象。这句话的实质是隐藏了toString的变换的：
由于汉字不是用一个字节来存储的，导致有被截破的汉字的存在，于是出现乱码。解决这个问题有一个简单的方案，是设置编码集：
这将得到一个正常的字符串响应：
遗憾的是目前Node.js仅支持hex、utf8、ascii、binary、base64、ucs2几种编码的转换。对于那些因为历史遗留问题依旧还生存着的GBK，GB2312等编码，该方法是无能为力的
string_decoder # 在这个例子中，如果仔细观察，会发现一件有趣的事情发生在设置编码集之后。我们提到data += trunk等价于data = data.toString() + trunk.toString()。通过以下的代码可以测试到一个汉字占用三个字节，而我们按11个字节来截取trunk的话，依旧会存在一个汉字被分割在两个trunk中的情景。
按照猜想的toString()方式，应该返回的是事件循xxx和请求xxx象才对，其中“环”字应该变成乱码才对，但是在设置了encoding（默认的utf8）之后，结果却正常显示了，这个结果十分有趣。
在好奇心的驱使下可以探查到data事件调用了string_decoder来进行编码补足的行为。通过string_decoder对象输出第一个截取Buffer(事件循xx)时，只返回事件循这个字符串，保留xx。第二次通过string_decoder对象输出时检测到上次保留的xx，将上次剩余内容和本次的Buffer进行重新拼接输出。于是达到正常输出的目的。
string_decoder，目前在文件流读取和网络流读取中都有应用到，一定程度上避免了粗鲁拼接trunk导致的乱码错误。但是，遗憾在于string_decoder目前只支持utf8编码。它的思路其实还可以扩展到其他编码上，只是最终是否会支持目前尚不可得知。
buffer正确使用 # 那么万能的适应各种编码而且正确的拼接Buffer对象的方法是什么呢？我们从Node.js在github上的源码中找出这样一段正确读取文件，并连接buffer对象的方法：
在end事件中通过细腻的连接方式，最后拿到理想的Buffer对象。这时候无论是在支持的编码之间转换，还是在不支持的编码之间转换（利用iconv模块转换），都不会导致乱码。
上述一大段代码仅只完成了一件事情，就是连接多个Buffer对象，而这种场景需求将会在多个地方发生，所以，采用一种更优雅的方式来完成该过程是必要的。笔者基于以上的代码封装出一个bufferhelper模块，用于更简洁地处理Buffer对象。可以通过NPM进行安装：
下面的例子演示了如何调用这个模块。与传统data += trunk之间只是bufferHelper.concat(chunk)的差别，既避免了错误的出现，又使得代码可以得到简化而有效地编写。
所以关于Buffer对象的操作的最佳实践是：
保持编码不变，以利于后续编码转换
使用封装方法达到简洁代码的目的
NodeJS提供的buffer # 参考buffer API: https://nodejs.org/api/buffer.html
最后我们看一下buffer的读取是如何进行的，buffer的读取主要包括以下几个api:
1、buf = new Buffer()，然后就可以直接读取buf
2、buf.toString([encoding], [start], [end])
3、buf.toJSON()
4、buf[index]
5、buf.slice([start], [end])
6、buf.readUInt8(offset, [noAssert])等其他read操作
buf = new Buffer() 和 buf[index] # 创建一个buf实例，会返回一个buf数组给这个实例，就像我们直接打印buf会出现以下内容：</description></item><item><title>node发送http请求以及参数处理</title><link>/fed-regain/node/node%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/node/node%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/</guid><description>“学骑自行车最快的方式就是先骑上去”
本文主要介绍如何发布自己的npm插件到npm社区，那么别人就可以直接使用npm install的命令安装你的模块了，并不会讲解npm模块的编写方法和相关知识，其实你可以自己研究一下其他npm模块的代码。本文最后会介绍如何删除自己发布的npm模块。
安装node和npm # 安装node(注意：需要Python 2.6或2.7已经安装)
成功安装node之后，npm(node package manager)已经包含在内了，不需要独立安装，可以执行一下npm检查是否安装好。
创建repository # 接下来我们需要创建module所需的repository，默认你拥有一个github账号（如果没有自行解决），这个repository用来托管我们module的代码，并方便用户报告bug，最重要的是可以让其他开发者向module贡献代码，这也是乐趣所在。
初始化package.json # 接下来我们创建package.json文件，这个文件包含了module的所有信息，比如名称、版本、描述、依赖、作者、license等。笔者以自己的easy_mongo(注意：npm要求项目的名称必须为小写字母)项目为例，看如何创建package.json。
首先创建我们module的目录
之后执行npm init，系统会提示你输入所需的信息，不想输入的直接输入Enter可以跳过。
输入完成之后，系统会要你确认文件的内容是否有误，如果没有问题直接输入yes，那么package.json就创建好了。
npm init创建的package.json文件只包含了基本的信息，我们还需要加入对其他module的依赖关系：
项目结构 # package.json文件只是第一步，要完成一个module，我们还需要许多其他文件，整体的文件夹结构如下：
这些文件的作用是：
持续集成 # 开源项目多如牛毛，从中找出靠谱的项目需要花费一定的精力，开发者都会对持续更新，并且经过测试（很多公司采用）的项目更加的信赖，对于刚上线并且用户数量很少的项目开发者都会有个疑虑：这项目靠谱吗？所以你需要对自己的项目打上一个标识：老子的项目靠谱。如何做？持续集成。
目前Github已经整合了持续集成服务travis，我们只需要在项目中添加.travis.yml文件，在下一次push之后，travis就会定时执行npm test来测试你的项目，并且会在测试失败的时候通知到你，你也可以把项目当前的状态显示在README.md中，让人一目了然，比如：
.travis.yml是一个YAML文件，关于node.js相关的配置见这里，例子如下：
这个例子的是让travis在node.js的0.6.x，0.8.x，0.10.x三个版本下对项目进行测试，并且需要mongodb的服务。
发布 # 完成了上面的步骤之后，我们接下来要在www.npmjs.org注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。
如果出现以下错误，可能是你的npm版本太低，通过sudo npm install -g npm升级一下。
成功之后，npm会把认证信息存储在~/.npmrc中，并且可以通过以下命令查看npm当前使用的用户：
以上完成之后，我们终于可以发布自己的module了：
npm社区版本号规则采用的是semver(语义化版本)，主要规则如下：
版本格式：主版号.次版号.修订号，版号递增规则如下：
主版号：当你做了不相容的 API 修改，
次版号：当你做了向下相容的功能性新增，
修订号：当你做了向下相容的问题修正。
先行版号及版本编译资讯可以加到「主版号.次版号.修订号」的后面，作为延伸。
至此，我们已经成功把module发布到了npmjs.org，是不是很简单，快动手把自己的module也贡献出来吧。
删除发布的模块 # 如何删除呢，执行下面的命令：
参考 # https://github.com/npm/npm https://www.npmjs.org/doc/api/npm-publish.html https://www.npmjs.org/doc/cli/npm-adduser.html https://docs.travis-ci.com/user/languages/javascript-with-nodejs/ https://docs.travis-ci.com/user/database-setup/ https://semver.org/ 谢谢！ # 转载请注明出处：//fed123.oss-ap-southeast-2.aliyuncs.com/2015/12/11/2015_npm_publish/
欢迎关注皓眸学问公众号（扫描左侧二维码），每天好文、新技术！任何学习疑问或者工作问题都可以给我留言、互动。T_T 皓眸大前端开发学习 T_T</description></item></channel></rss>