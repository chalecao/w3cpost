<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微前端 on</title><link>/fed-regain/microfe/</link><description>Recent content in 微前端 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:15 +0000</lastBuildDate><atom:link href="/fed-regain/microfe/index.xml" rel="self" type="application/rss+xml"/><item><title>基于config-component转向面向数据的编程</title><link>/fed-regain/microfe/%E5%9F%BA%E4%BA%8Econfig-component%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/microfe/%E5%9F%BA%E4%BA%8Econfig-component%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A8%8B/</guid><description>面向数据编程 # 面向数据编程是什么样的体验？ # 其实是数据驱动式编程更向前走一步，我们知道现在MVVM框架，像React、vue、Angular这些给前端带来了很大的进步，更优雅的工程化体系结构，更健壮的代码体系结构。同样给开发者带来了数据驱动式开发的体验，但是业务代码还是经常会出现业务逻辑与UI表达形式的穿插混合的情况，很难统一。
github： https://github.com/chalecao/c…
感谢star！！！
样式行为分离 # 面向数据的编程其实核心思想还是做样式行为分离，中间的解耦利器便是数据。
样式 mix 行为 = 样式 + 数据 + 行为
于是我们抽象出来的config-component组件，作为驱动样式行为分离的通用组件，驱动面向数据编程。
例如实现下面的表单：
基于antd组件库，比较下不同的代码结构：
左边的图是基于ANTD正常的写法，我们要写Form，要写检验规则，要写子组件等等，关键是这些逻辑是糅合在一起的。右边是基于config-component提供的ConfigForm组件做了封装，只需要提供JSON schema配置数据即可驱动你的页面，分离数据校验和UI逻辑，UI逻辑基于UIconfig，数据校验基于schema做校验。
creative feature创新特性 # ✅ change your code style to face data, use JSON schema config to driven you page.数据驱动式开发更进一步转向面向数据编程，结合React Hooks开发更高效，专注于数据和业务逻辑.基于JSON配置数据驱动你的页面或者表单。
✅ add schema mechanism to ensure you data correct and force you to care you data and handle the abnormal situation.开发中引入schema机制验证核心数据的正确性，无论是表单还是前台组件均可适用。
✅ support get data async, verify data when it changes.</description></item><item><title>基于webcomponents的实现</title><link>/fed-regain/microfe/%E5%9F%BA%E4%BA%8Ewebcomponents%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/microfe/%E5%9F%BA%E4%BA%8Ewebcomponents%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>什么是Micro Frontends？ # Micro Frontends这个术语在2016年底首次出现在[ThoughtWorks技术雷达][1]中。它将微服务的概念扩展到前端世界。目前的趋势是构建一个功能丰富且功能强大的浏览器应用程序，即单页面应用程序，它位于微服务架构之上。随着时间的推移，前端层通常由一个单独的团队开发，并且变得越来越难以维护。这就是我们所说的[Frontend Monolith][2]。
Micro Frontends背后的想法是将网站或Web应用程序视为独立团队拥有的功能组合。每个团队都有一个独特的业务或任务****领域，它关注和专注。团队是跨职能的，从数据库到用户界面开发端到端的功能。
然而，这个想法并不新鲜，过去它的名称是[垂直系统][3]或[自包含系统][4]的[前端集成][3]。但Micro Frontends显然是一个更友好，更笨重的术语。
单片前端 ![单片前端][5]
垂直组织 ![具有Micro Frontends的端到端团队][6]
什么是现代Web应用程序？ # 在介绍中，我使用了“构建现代Web应用程序”这一短语。让我们定义与该术语相关的假设。
为了更广泛地看待这一点，[Aral Balkan][7]撰写了一篇关于他称之为[Documents-to-Applications Continuum][8]的博客文章。他提出了滑动比例的概念，其中一个由静态文档构建的站点，通过链接连接在左端，一个纯粹的行为驱动，无内容应用程序，如在线照片编辑器在右边。
如果您将项目放在此频谱的左侧，则在Web服务器级别进行集成是一个不错的选择。使用此模型，服务器从构成用户请求的页面的所有组件中收集和连接HTML字符串。通过从服务器重新加载页面或通过ajax替换部分页面来完成更新。[Gustaf Nilsson Kotte][9]撰写了[一篇][10]关于这一主题的[综合文章][10]。
当您的用户界面必须提供即时反馈时，即使在不可靠的连接上，纯服务器渲染的站点也不再足够。要实现[Optimistic UI][11]或[Skeleton Screens等技术，][12]您还需要能够在设备上****更新UI 。Google的术语[Progressive Web Apps][13]恰当地描述了成为网络的良好公民（渐进增强）的平衡行为，同时还提供类似应用程序的性能。这种应用程序位于site-app-continuum中间的某个位置。这里仅基于服务器的解决方案已不再适用。我们要搬家了集成到浏览器中，这是本文的重点。
Micro Frontends背后的核心理念 # 技术不可知
每个团队都应该能够选择并升级他们的筹码，而无需与其他团队协调。[自定义元素][14]是隐藏实现细节的好方法，同时为其他人提供中性界面。 隔离团队代码
即使所有团队使用相同的框架，也不要共享运行时。构建自包含的独立应用程序。不要依赖共享的状态或全局变量。 建立团队前缀
同意在无法实现隔离的命名约定。命名空间CSS，事件，本地存储和Cookie，以避免冲突并澄清所有权。 支持自定义API上的本机浏览器功能
使用[浏览器事件进行通信，][15]而不是构建全局PubSub系统。如果您真的需要构建跨团队API，请尽量保持简单。 构建弹性站点
即使JavaScript失败或尚未执行，您的功能也应该很有用。使用[通用渲染][16]和渐进增强来提高感知性能。 DOM是API # [自定义元素][17]（Web Components Spec的互操作性方面）是在浏览器中集成的良好原语。每个团队建立他们的组件使用他们所选择的网络技术，并把它包装自定义元素中（如）。此特定元素的DOM规范（标记名称，属性和事件）充当其他团队的合同或公共API。优点是他们可以使用组件及其功能，而无需了解实现。他们只需要能够与DOM交互。
但仅限定制元素并不是我们所有需求的解决方案。为了解决渐进增强，通用渲染或路由问题，我们需要额外的软件。
本页面分为两个主要区域。首先，我们将讨论[页面组合][18] - 如何从不同团队拥有的组件中组装页面。之后，我们将展示实现客户端[页面转换的][19]示例。
页面组成 # 除了在不同框架本身编写的代码的客户端和服务器端集成之外，还有许多应该讨论的副主题：隔离js的机制，避免css冲突，根据需要加载资源，在团队之间共享公共资源，处理数据获取并考虑用户的良好加载状态。我们将一步一步地讨论这些主题。
基础原型 # 该型号拖拉机商店的产品页面将作为以下示例的基础。
它具有一个变量选择器，可在三种不同的拖拉机型号之间切换。在更改产品图像时，将更新名称，价格和建议。还有一个购买按钮，可以将选定的变体添加到篮子中，并在顶部添加相应更新的迷你篮子。
[![示例0 - 产品页面 - Plain JS][20]][21]
[尝试在浏览器][21]和[检查码][22]
所有HTML都是使用纯JavaScript和ES6模板字符串生成的客户端，没有依赖项。代码使用简单的状态/标记分离，并在每次更改时重新呈现整个HTML客户端 - 没有花哨的DOM差异，现在也没有通用渲染。也没有团队分离 - [代码][22]写在一个js / css文件中。</description></item><item><title>微前端架构的一些想法</title><link>/fed-regain/microfe/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/fed-regain/microfe/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</guid><description>Web 应用的聚合 # 为什么微前端开始在流行?
采用新技术，更多不是因为先进，而是因为它能解决痛点。
过去，我一直有一个疑惑，人们是否真的需要微服务，是否真的需要微前端。毕竟，没有银弹。当人们考虑是否采用一种新的架构，除了考虑它带来好处之外，仍然也考量着存在的大量的风险和技术挑战。
前端遗留系统迁移 # 解决遗留系统，才是人们采用微前端方案最重要的原因。
这些咨询里，开发人员所遇到的情况，与我之前遇到的情形并相似，我的场景是：设计一个新的前端架构。他们开始考虑前端微服务化，是因为遗留系统的存在。
过去那些使用 Backbone.js、Angular.js、Vue.js 1 等等框架所编写的单页面应用，已经在线上稳定地运行着，也没有新的功能。对于这样的应用来说，我们也没有理由浪费时间和精力重写旧的应用。这里的那些使用旧的、不再使用的技术栈编写的应用，可以称为遗留系统。而，这些应用又需要结合到新应用中使用。我遇到的较多的情况是：旧的应用使用的是 Angular.js 编写，而新的应用开始采用 Angular 2+。这对于业务稳定的团队来说，是极为常见的技术栈。
在即不重写原有系统的基础之下，又可以抽出人力来开发新的业务。其不仅仅对于业务人员来说， 是一个相当吸引力的特性；对于技术人员来说，不重写旧的业务，同时还能做一些技术上的挑战，也是一件相当有挑战的事情。
后端解耦，前端聚合 # 而前端微服务的一个卖点也在这里，去兼容不同类型的前端框架。这让我又联想到微服务的好处，及许多项目落地微服务的原因：
在初期，后台微服务的一个很大的卖点在于，可以使用不同的技术栈来开发后台应用。但是，事实上，采用微服务架构的组织和机构，一般都是中大型规模的。相较于中小型，对于框架和语言的选型要求比较严格，如在内部限定了框架，限制了语言。因此，在充分使用不同的技术栈来发挥微服务的优势这一点上，几乎是很少出现的。在这些大型组织机构里，采用微服务的原因主要还是在于，使用微服务架构来解耦服务间依赖。
而在前端微服务化上，则是恰恰与之相反的，人们更想要的结果是聚合，尤其是那些 To B（to Bussiness）的应用。
在这两三年里，移动应用出现了一种趋势，用户不想装那么多应用了。而往往一家大的商业公司，会提供一系列的应用。这些应用也从某种程度上，反应了这家公司的组织架构。然而，在用户的眼里他们就是一家公司，他们就只应该有一个产品。相似的，这种趋势也在桌面 Web 出现。聚合成为了一个技术趋势，体现在前端的聚合就是微服务化架构。
兼容遗留系统 # 那么，在这个时候，我们就需要使用新的技术、新的架构，来容纳、兼容这些旧的应用。而前端微服务化，正好是契合人们想要的这个卖点呗了。
实施微前端的六种方式 # 微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。
由此带来的变化是，这些前端应用可以独立运行、独立开发、独立部署。以及，它们应该可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。
注意：这里的前端应用指的是前后端分离的单应用页面，在这基础才谈论微前端才有意义。
结合我最近半年在微前端方面的实践和研究来看，微前端架构一般可以由以下几种方式进行：
使用 HTTP 服务器的路由来重定向多个应用 在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA 通过组合多个独立应用、组件来构建一个单体应用 iFrame。使用 iFrame 及自定义消息传递机制 使用纯 Web Components 构建应用 结合 Web Components 构建 基础铺垫：应用分发路由 -&amp;gt; 路由分发应用 # 在一个单体前端、单体后端应用中，有一个典型的特征，即路由是由框架来分发的，框架将路由指定到对应的组件或者内部服务中。微服务在这个过程中做的事情是，将调用由函数调用变成了远程调用，诸如远程 HTTP 调用。而微前端呢，也是类似的，它是将应用内的组件调用变成了更细粒度的应用间组件调用，即原先我们只是将路由分发到应用的组件执行，现在则需要根据路由来找到对应的应用，再由应用分发到对应的组件上。</description></item></channel></rss>